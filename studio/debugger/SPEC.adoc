// SPDX-License-Identifier: PMPL-1.0-or-later
= Lithoglyph Debugger: Verified Database Recovery & Introspection
:toc:
:toc-placement!:
:sectnums:

A proof-carrying debugger for database troubleshooting, recovery, and introspection using Lean 4 and Idris 2.

toc::[]

== Overview

=== The Problem

Current database debugging tools are fundamentally limited:

[cols="1,2"]
|===
| Tool | Limitation

| `EXPLAIN ANALYZE` | Read-only, no recovery
| WAL viewers | Raw bytes, no semantic understanding
| pg_dump/restore | All-or-nothing, no surgical repair
| Transaction logs | Post-mortem only
| Database GUIs | Visual inspection without verification
|===

When something goes wrong—data corruption, failed migration, constraint violation cascade—database administrators rely on intuition, experience, and hope. There's no way to _prove_ a recovery operation is safe before executing it.

=== The Solution

Lithoglyph Debugger provides:

1. **Proof-Carrying Recovery Plans** - Every recovery operation comes with a machine-checked proof that it preserves data integrity
2. **Type-Safe Introspection** - Browse database state with dependent types that encode invariants
3. **Reversible Operations** - All debug operations are reversible with proofs of reversibility
4. **Temporal Navigation** - "Time travel" through database states with provenance tracking
5. **Constraint Violation Analysis** - When constraints fail, understand exactly why and how to fix it

== Architecture

=== Core Components

[source]
----
formdb-debugger/
├── core/                    # Lean 4 core library
│   ├── Proofs/             # Recovery proof tactics
│   │   ├── Lossless.lean   # Lossless join proofs
│   │   ├── FDPreserving.lean
│   │   └── Rollback.lean
│   ├── State/              # Database state representation
│   │   ├── Snapshot.lean
│   │   ├── Delta.lean
│   │   └── Transaction.lean
│   └── Types/              # Dependent types for DB objects
│       ├── Schema.lean
│       ├── Constraint.lean
│       └── Query.lean
├── idris/                   # Idris 2 interactive shell
│   ├── REPL/               # Debug REPL
│   ├── Inspector/          # Live data inspection
│   └── Recovery/           # Recovery operations
├── adapters/               # Database adapters (Rust)
│   ├── postgres/
│   ├── formdb/
│   └── sqlite/
└── ui/                     # Terminal UI (Rust + Ratatui)
    └── src/
----

=== Type Universe

[source,lean]
----
-- Core database state representation in Lean 4

/-- A database schema with dependent types encoding constraints -/
structure Schema where
  name : String
  tables : List Table
  constraints : (t : Table) → t ∈ tables → List (Constraint t)
  fds : List FunctionalDependency

/-- A table with its columns and primary key -/
structure Table where
  name : String
  columns : List Column
  primaryKey : Sublist Column columns

/-- A column with its type and nullability -/
structure Column where
  name : String
  dtype : DataType
  nullable : Bool
  check : Option (Value dtype → Bool)

/-- A snapshot of database state at a point in time -/
structure Snapshot (s : Schema) where
  timestamp : Timestamp
  tables : (t : Table) → t ∈ s.tables → TableData t
  valid : AllConstraintsSatisfied s tables

/-- A delta between two snapshots -/
structure Delta (s : Schema) (before after : Snapshot s) where
  changes : List (Change s)
  produces : ApplyChanges before changes = after
----

=== Proof Obligations

Every recovery operation generates proof obligations:

[source,lean]
----
/-- A recovery plan with its associated proofs -/
structure RecoveryPlan (s : Schema) (current : Snapshot s) where
  target : Snapshot s
  steps : List (RecoveryStep s)

  -- Proof that steps transform current to target
  correctness : ApplySteps current steps = target

  -- Proof that target satisfies all constraints
  validity : AllConstraintsSatisfied s target.tables

  -- Proof that the operation is reversible
  reversibility : ∃ inverse, ApplySteps target inverse = current

  -- Proof that no data is lost (for non-destructive ops)
  lossless : ∀ row ∈ current, row ∈ target ∨ row ∈ archived

/-- A single recovery step -/
inductive RecoveryStep (s : Schema) where
  | insert : (t : Table) → t ∈ s.tables → Row t → RecoveryStep s
  | delete : (t : Table) → t ∈ s.tables → RowId → RecoveryStep s
  | update : (t : Table) → t ∈ s.tables → RowId → Row t → RecoveryStep s
  | migrate : Schema → (Schema → Schema) → RecoveryStep s
  | checkpoint : String → RecoveryStep s
----

== Features

=== 1. Constraint Violation Debugger

When a constraint fails, the debugger traces the exact cause:

[source]
----
formdb-debug> explain violation fk_author_id

Constraint Violation Analysis
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Constraint: evidence.author_id REFERENCES authors(id)
Violation:  Row evidence[42] references authors[7] which does not exist

Trace:
  1. Transaction 0x4a7f began at 2024-01-15T10:23:45Z
  2. DELETE FROM authors WHERE id = 7  ← This removed the referenced row
  3. Transaction committed (constraint check was deferred)
  4. INSERT INTO evidence (author_id = 7)  ← This created the orphan

Suggested Fixes:
  [1] Re-insert the deleted author (proof: FK_SATISFIED)
      INSERT INTO authors (id, name) VALUES (7, 'Unknown Author');

  [2] Update evidence to reference existing author (proof: FK_SATISFIED)
      UPDATE evidence SET author_id = 1 WHERE id = 42;

  [3] Delete the orphaned evidence row (proof: CASCADE_SAFE)
      DELETE FROM evidence WHERE id = 42;

View proof? [1/2/3/q]:
----

=== 2. Temporal Navigation

Navigate through database history with proofs of state consistency:

[source]
----
formdb-debug> timeline

Database Timeline: evidence_db
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[2024-01-15 10:00] Snapshot α₀ ────┬─── Schema: v3.2
                                   │    Tables: 12
                                   │    Rows: 45,231
                                   │    Constraints: ✓ All satisfied
                                   │
[2024-01-15 10:23] Delta δ₁ ──────┤    - DELETE authors WHERE id = 7
                                   │
[2024-01-15 10:24] Delta δ₂ ──────┤    - INSERT evidence (author_id = 7)
                                   │    ⚠ FK violation introduced
                                   │
[2024-01-15 10:30] Snapshot α₁ ───┴─── Current state
                                       Constraints: ✗ 1 violation

formdb-debug> goto 2024-01-15T10:00

Traveling to snapshot α₀...
Proof: TEMPORAL_CONSISTENT ✓
State loaded (read-only view)

formdb-debug> diff current

Changes since α₀:
  authors: -1 row (id=7)
  evidence: +1 row (id=42, author_id=7 ← ORPHAN)
----

=== 3. Recovery Plan Generation

Generate verified recovery plans:

[source]
----
formdb-debug> recover --verify

Analyzing constraint violations...
Found 1 violation in evidence_db

Generating recovery plan...

Recovery Plan #1
━━━━━━━━━━━━━━━

Strategy: RESTORE_REFERENT
Steps:
  1. INSERT INTO authors (id, name, email)
     VALUES (7, '[RECOVERED]', 'unknown@recovered.local')

Proofs:
  ✓ FK_SATISFIED: After step 1, evidence.author_id → authors.id
  ✓ LOSSLESS: No data removed
  ✓ REVERSIBLE: DELETE authors WHERE id = 7 restores previous state
  ✓ MINIMAL: Smallest change to satisfy constraints

Execute plan? [y/n/view-proof]:
----

=== 4. Schema Migration Verification

Verify migrations preserve data:

[source,lean]
----
-- Migration verification theorem
theorem migration_lossless
  (old_schema : Schema)
  (new_schema : Schema)
  (migrate : Migration old_schema new_schema)
  (data : Snapshot old_schema)
  : ∃ (data' : Snapshot new_schema),
    (∀ row ∈ data, ∃ row' ∈ data', Equivalent row row') ∧
    AllConstraintsSatisfied new_schema data'.tables := by
  -- Proof tactics here
  apply Migration.preserves_data
  apply migrate.lossless_proof
  done
----

Terminal output:
[source]
----
formdb-debug> verify-migration migrations/v4.0.sql

Analyzing migration: v3.2 → v4.0

Changes detected:
  + ADD COLUMN evidence.verified : Bool DEFAULT false
  + ADD TABLE verification_log
  ~ RENAME authors.email → authors.contact_email

Checking proofs...
  ✓ ADD_COLUMN_SAFE: Default value provided, existing rows unaffected
  ✓ ADD_TABLE_SAFE: No dependencies on new table yet
  ✓ RENAME_SAFE: All references updated in migration

Data preservation check...
  ✓ All 45,231 rows accounted for in new schema
  ✓ No data type narrowing (potential data loss)
  ✓ No constraint violations after migration

Migration verified: SAFE TO APPLY
----

== Idris 2 Interactive Shell

The debug shell uses Idris 2 for its powerful dependent type system and REPL:

[source,idris]
----
-- Idris 2 types for debug operations

||| A proven-safe query that cannot violate constraints
data SafeQuery : (s : Schema) -> Type where
  MkSafeQuery : (q : Query s)
             -> (proof : QueryPreservesConstraints q)
             -> SafeQuery s

||| A recovery operation with its proof
data ProvenRecovery : (s : Schema) -> (before, after : Snapshot s) -> Type where
  MkRecovery : (steps : List (RecoveryStep s))
            -> (valid : AllConstraintsSatisfied s after.tables)
            -> (reversible : Reversible steps)
            -> ProvenRecovery s before after

||| Interactive debugging session
record DebugSession where
  constructor MkSession
  schema : Schema
  current : Snapshot schema
  history : List (Delta schema)

||| Navigate to a point in time
goto : (session : DebugSession)
    -> (timestamp : Timestamp)
    -> Either TimeNotFound (DebugSession, ProofOf (AtTime timestamp))

||| Generate recovery plan
recover : (session : DebugSession)
       -> (target : ConstraintSet)
       -> Either NoSolution (ProvenRecovery session.schema session.current newState)
----

== Implementation Plan

=== Phase 1: Core Proof Library (Lean 4)

* [ ] Define Schema, Table, Column types
* [ ] Define Snapshot and Delta types
* [ ] Implement constraint checking proofs
* [ ] Implement lossless join proofs
* [ ] Implement reversibility proofs

=== Phase 2: Database Adapters (Rust)

* [ ] PostgreSQL adapter (pg_catalog inspection)
* [ ] Lithoglyph adapter (native)
* [ ] SQLite adapter (for testing)
* [ ] WAL parsing for each database
* [ ] Transaction log extraction

=== Phase 3: Idris 2 REPL

* [ ] REPL framework
* [ ] Schema loading
* [ ] Query execution with type checking
* [ ] Recovery plan generation
* [ ] Proof display and verification

=== Phase 4: Terminal UI

* [ ] Ratatui-based TUI
* [ ] Timeline visualization
* [ ] Constraint violation browser
* [ ] Recovery plan wizard
* [ ] Proof inspector

== Integration with Lithoglyph Ecosystem

[source]
----
┌─────────────────────────────────────────────────────────────┐
│                     Lithoglyph Ecosystem                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────┐   ┌──────────────┐   ┌──────────────────┐ │
│  │ Lithoglyph Core  │   │ Lithoglyph Studio│   │ Lithoglyph Debugger  │ │
│  │  (Storage)   │◄──│    (UI)      │◄──│ (This Project)   │ │
│  └──────────────┘   └──────────────┘   └──────────────────┘ │
│         ▲                  ▲                   ▲             │
│         │                  │                   │             │
│  ┌──────┴──────────────────┴───────────────────┴──────────┐ │
│  │                        GQLdt                            │ │
│  │        (Dependently-Typed Form Query Language)          │ │
│  └────────────────────────────────────────────────────────┘ │
│         ▲                                                    │
│         │                                                    │
│  ┌──────┴──────────────────────────────────────────────────┐│
│  │                      Lean 4 Core                         ││
│  │  (Schema proofs, Normalization proofs, Recovery proofs)  ││
│  └──────────────────────────────────────────────────────────┘│
│                                                              │
└─────────────────────────────────────────────────────────────┘
----

== Use Cases

=== Use Case 1: Corrupted Index Recovery

A production database has a corrupted index causing incorrect query results.

[source]
----
formdb-debug> diagnose

Running diagnostic checks...
  ✓ Schema integrity
  ✓ Foreign key consistency
  ✗ Index 'idx_evidence_claim' inconsistent with table data

Details:
  Index reports 45,231 rows
  Table contains 45,234 rows
  Missing from index: rows 45232, 45233, 45234

formdb-debug> recover idx_evidence_claim

Recovery Plan:
  1. REINDEX idx_evidence_claim

Proofs:
  ✓ INDEX_REBUILD_SAFE: No data modification
  ✓ QUERY_RESULTS_CONSISTENT: Post-rebuild queries match table scan

Estimated time: ~2 minutes (45K rows)
Execute? [y/n]:
----

=== Use Case 2: Failed Migration Rollback

A migration failed halfway, leaving the database in an inconsistent state.

[source]
----
formdb-debug> analyze-migration-failure

Migration 'v4.0' failed at step 3 of 5:
  ✓ Step 1: ADD COLUMN evidence.verified
  ✓ Step 2: ADD TABLE verification_log
  ✗ Step 3: ALTER TABLE authors RENAME email → contact_email
            Error: Column referenced by view 'author_report'
  ⋯ Step 4: (not executed)
  ⋯ Step 5: (not executed)

Current state: PARTIALLY MIGRATED (inconsistent)

formdb-debug> generate-rollback

Rollback Plan:
  1. DROP TABLE verification_log
  2. ALTER TABLE evidence DROP COLUMN verified

Proofs:
  ✓ ROLLBACK_COMPLETE: Returns to v3.2 state
  ✓ NO_DATA_LOSS: verification_log is empty, verified column has only defaults
  ✓ CONSTRAINT_RESTORED: All v3.2 constraints satisfied

Execute rollback? [y/n]:
----

=== Use Case 3: Audit-Grade Recovery Documentation

For regulated industries that need proof of data integrity.

[source]
----
formdb-debug> recover --audit-trail

Recovery executed at 2024-01-15T14:30:00Z
Transaction ID: 0x7f3a2b

Formal Verification Report
━━━━━━━━━━━━━━━━━━━━━━━━━━

Operation: INSERT authors (id=7, name='[RECOVERED]')

Theorems Verified:
  1. ForeignKey.Satisfied
     ∀ row ∈ evidence, ∃ author ∈ authors, row.author_id = author.id
     Proof: [QED via omega tactic]

  2. Schema.Unchanged
     schema_before = schema_after
     Proof: [QED via rfl]

  3. DataIntegrity.Preserved
     ∀ row ∈ data_before, row ∈ data_after
     Proof: [QED via set membership]

  4. Operation.Reversible
     ∃ inverse, apply(apply(state, op), inverse) = state
     Proof: inverse = DELETE authors WHERE id = 7
            [QED via inverse construction]

Proof artifacts saved to: /audit/2024-01-15/recovery_0x7f3a2b.lean
Verified by: Lean 4.3.0
----

== Why Lean 4 + Idris 2?

=== Lean 4 for Core Proofs

* **Tactics** - Powerful proof automation (omega, simp, decide)
* **Performance** - Compiled to efficient native code
* **Metaprogramming** - Can generate custom tactics for DB operations
* **Mathlib** - Rich mathematical foundations

=== Idris 2 for Interactive Shell

* **Dependent Types** - Types that encode database constraints
* **First-Class Types** - Types can be computed and inspected at runtime
* **REPL** - Interactive exploration of database state
* **Quantitative Types** - Track linearity for resource management

=== Rust for Database Adapters

* **Performance** - Zero-cost abstractions for DB communication
* **Ecosystem** - Excellent database driver libraries
* **FFI** - Easy integration with Lean 4 and Idris 2
* **Memory Safety** - No buffer overflows in adapter code

== References

* link:https://github.com/hyperpolymath/formdb[Lithoglyph Core]
* link:https://github.com/hyperpolymath/fqldt[GQLdt Specification]
* link:https://github.com/hyperpolymath/formdb-studio[Lithoglyph Studio]
* link:https://lean-lang.org/[Lean 4]
* link:https://idris2.org/[Idris 2]
