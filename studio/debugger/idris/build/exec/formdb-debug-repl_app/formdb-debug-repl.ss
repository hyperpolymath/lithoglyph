#!/home/hyper/.local/bin/scheme --program

;; @generated by Idris 0.8.0, Chez backend
(import (chezscheme))
(case (machine-type)
  [(i3fb ti3fb a6fb ta6fb) #f]
  [(i3le ti3le a6le ta6le tarm64le)
     (with-exception-handler (lambda(x) (load-shared-object "libc.so"))
        (lambda () (load-shared-object "libc.so.6")))]
  [(i3osx ti3osx a6osx ta6osx tarm64osx tppc32osx tppc64osx) (load-shared-object "libc.dylib")]
  [(i3nt ti3nt a6nt ta6nt) (load-shared-object "msvcrt.dll")]
  [else (load-shared-object "libc.so")])

(load-shared-object "libidris2_support.so")

(let ()
#!chezscheme

(define (blodwen-os)
  (case (machine-type)
    [(i3le ti3le a6le ta6le tarm64le) "unix"]  ; GNU/Linux
    [(i3ob ti3ob a6ob ta6ob tarm64ob) "unix"]  ; OpenBSD
    [(i3fb ti3fb a6fb ta6fb tarm64fb) "unix"]  ; FreeBSD
    [(i3nb ti3nb a6nb ta6nb tarm64nb) "unix"]  ; NetBSD
    [(i3osx ti3osx a6osx ta6osx tarm64osx tppc32osx tppc64osx) "darwin"]
    [(i3nt ti3nt a6nt ta6nt tarm64nt) "windows"]
    [else "unknown"]))

(define blodwen-lazy
  (lambda (f)
    (let ([evaluated #f] [res void])
      (lambda ()
        (if (not evaluated)
            (begin (set! evaluated #t)
                   (set! res (f))
                   (set! f void))
            (void))
        res))))

(define (blodwen-delay-lazy f)
  (weak-cons #!bwp f))

(define (blodwen-force-lazy e)
  (let ((exval (car e)))
    (if (bwp-object? exval)
      (let ((val ((cdr e))))
        (begin (set-car! e val) val))
      exval)))

(define (blodwen-toSignedInt x bits)
  (if (logbit? bits x)
      (logor x (ash -1 bits))
      (logand x (sub1 (ash 1 bits)))))

(define (blodwen-toUnsignedInt x bits)
  (logand x (sub1 (ash 1 bits))))

(define (blodwen-euclidDiv a b)
  (let ((q (quotient a b))
        (r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (- q 1) (+ q 1))
      q)))

(define (blodwen-euclidMod a b)
  (let ((r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (+ r b) (- r b))
      r)))

; flonum constants

(define (blodwen-calcFlonumUnitRoundoff)
  (let loop [(uro 1.0)]
    (if (fl= 1.0 (fl+ 1.0 uro))
      uro
      (loop (fl/ uro 2.0)))))

(define (blodwen-calcFlonumEpsilon)
  (fl* (blodwen-calcFlonumUnitRoundoff) 2.0))

(define (blodwen-flonumNaN)
  +nan.0)

(define (blodwen-flonumInf)
  +inf.0)

; Bits

(define bu+ (lambda (x y bits) (blodwen-toUnsignedInt (+ x y) bits)))
(define bu- (lambda (x y bits) (blodwen-toUnsignedInt (- x y) bits)))
(define bu* (lambda (x y bits) (blodwen-toUnsignedInt (* x y) bits)))
(define bu/ (lambda (x y bits) (blodwen-toUnsignedInt (quotient x y) bits)))

(define bs+ (lambda (x y bits) (blodwen-toSignedInt (+ x y) bits)))
(define bs- (lambda (x y bits) (blodwen-toSignedInt (- x y) bits)))
(define bs* (lambda (x y bits) (blodwen-toSignedInt (* x y) bits)))
(define bs/ (lambda (x y bits) (blodwen-toSignedInt (blodwen-euclidDiv x y) bits)))

(define (integer->bits8 x) (logand x (sub1 (ash 1 8))))
(define (integer->bits16 x) (logand x (sub1 (ash 1 16))))
(define (integer->bits32 x) (logand x (sub1 (ash 1 32))))
(define (integer->bits64 x) (logand x (sub1 (ash 1 64))))

(define (bits16->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits64->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits32 x) (logand x (sub1 (ash 1 32))))

(define (blodwen-bits-shl-signed x y bits) (blodwen-toSignedInt (ash x y) bits))

(define (blodwen-bits-shl x y bits) (logand (ash x y) (sub1 (ash 1 bits))))

(define blodwen-shl (lambda (x y) (ash x y)))
(define blodwen-shr (lambda (x y) (ash x (- y))))
(define blodwen-and (lambda (x y) (logand x y)))
(define blodwen-or (lambda (x y) (logor x y)))
(define blodwen-xor (lambda (x y) (logxor x y)))

(define cast-num
  (lambda (x)
    (if (number? x) x 0)))
(define destroy-prefix
  (lambda (x)
    (cond
      ((equal? x "") "")
      ((equal? (string-ref x 0) #\#) "")
      (else x))))

(define exact-floor
  (lambda (x)
    (inexact->exact (floor x))))

(define exact-truncate
  (lambda (x)
    (inexact->exact (truncate x))))

(define exact-truncate-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (exact-truncate x) y)))

(define exact-truncate-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (exact-truncate x) y)))

(define cast-char-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (char->integer x) y)))

(define cast-char-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (char->integer x) y)))

(define cast-string-int
  (lambda (x)
    (exact-truncate (cast-num (string->number (destroy-prefix x))))))

(define cast-string-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (cast-string-int x) y)))

(define cast-string-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (cast-string-int x) y)))

(define cast-int-char
  (lambda (x)
    (if (or
          (and (>= x 0) (<= x #xd7ff))
          (and (>= x #xe000) (<= x #x10ffff)))
        (integer->char x)
        (integer->char 0))))

(define cast-string-double
  (lambda (x)
    (exact->inexact (cast-num (string->number (destroy-prefix x))))))


(define (string-concat xs) (apply string-append xs))
(define (string-unpack s) (string->list s))
(define (string-pack xs) (list->string xs))

(define string-cons (lambda (x y) (string-append (string x) y)))
(define string-reverse (lambda (x)
  (list->string (reverse (string->list x)))))
(define (string-substr off len s)
    (let* ((l (string-length s))
          (b (max 0 off))
          (x (max 0 len))
          (end (min l (+ b x))))
          (if (> b l)
              ""
              (substring s b end))))

(define (blodwen-string-iterator-new s)
  0)

(define (blodwen-string-iterator-to-string _ s ofs f)
  (f (substring s ofs (string-length s))))

(define (blodwen-string-iterator-next s ofs)
  (if (>= ofs (string-length s))
      '() ; EOF
      (cons (string-ref s ofs) (+ ofs 1))))

(define either-left
  (lambda (x)
    (vector 0 x)))

(define either-right
  (lambda (x)
    (vector 1 x)))

(define blodwen-error-quit
  (lambda (msg)
    (display msg)
    (newline)
    (exit 1)))

(define (blodwen-get-line p)
    (if (port? p)
        (let ((str (get-line p)))
            (if (eof-object? str)
                ""
                str))
        void))

(define (blodwen-get-char p)
    (if (port? p)
        (let ((chr (get-char p)))
            (if (eof-object? chr)
                #\nul
                chr))
        void))

;; Buffers

(define (blodwen-new-buffer size)
  (make-bytevector size 0))

(define (blodwen-buffer-size buf)
  (bytevector-length buf))

(define (blodwen-buffer-setbyte buf loc val)
  (bytevector-u8-set! buf loc val))

(define (blodwen-buffer-getbyte buf loc)
  (bytevector-u8-ref buf loc))

(define (blodwen-buffer-setbits16 buf loc val)
  (bytevector-u16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits16 buf loc)
  (bytevector-u16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits32 buf loc val)
  (bytevector-u32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits32 buf loc)
  (bytevector-u32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits64 buf loc val)
  (bytevector-u64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits64 buf loc)
  (bytevector-u64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint8 buf loc val)
  (bytevector-s8-set! buf loc val))

(define (blodwen-buffer-getint8 buf loc)
  (bytevector-s8-ref buf loc))

(define (blodwen-buffer-setint16 buf loc val)
  (bytevector-s16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint16 buf loc)
  (bytevector-s16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint32 buf loc val)
  (bytevector-s32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint32 buf loc)
  (bytevector-s32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint64 buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint64 buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setdouble buf loc val)
  (bytevector-ieee-double-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getdouble buf loc)
  (bytevector-ieee-double-ref buf loc (native-endianness)))

(define (blodwen-stringbytelen str)
  (bytevector-length (string->utf8 str)))

(define (blodwen-buffer-setstring buf loc val)
  (let* [(strvec (string->utf8 val))
         (len (bytevector-length strvec))]
    (bytevector-copy! strvec 0 buf loc len)))

(define (blodwen-buffer-getstring buf loc len)
  (let [(newvec (make-bytevector len))]
    (bytevector-copy! buf loc newvec 0 len)
    (utf8->string newvec)))

(define (blodwen-buffer-copydata buf start len dest loc)
  (bytevector-copy! buf start dest loc len))

;; Threads

(define-record thread-handle (semaphore))

(define (blodwen-thread proc)
  (let [(sema (blodwen-make-semaphore 0))]
    (fork-thread (lambda () (proc (vector 0)) (blodwen-semaphore-post sema)))
    (make-thread-handle sema)
    ))

(define (blodwen-thread-wait handle)
  (blodwen-semaphore-wait (thread-handle-semaphore handle)))

;; Thread mailboxes

(define blodwen-thread-data
  (make-thread-parameter #f))

(define (blodwen-get-thread-data ty)
  (blodwen-thread-data))

(define (blodwen-set-thread-data ty a)
  (blodwen-thread-data a))

;; Semaphore

(define-record semaphore (box mutex condition))

(define (blodwen-make-semaphore init)
  (make-semaphore (box init) (make-mutex) (make-condition)))

(define (blodwen-semaphore-post sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (set-box! sema-box (+ (unbox sema-box) 1))
      (condition-signal (semaphore-condition sema))
    )))

(define (blodwen-semaphore-wait sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (when (= (unbox sema-box) 0)
        (condition-wait (semaphore-condition sema) (semaphore-mutex sema)))
      (set-box! sema-box (- (unbox sema-box) 1))
      )))

;; Barrier

(define-record barrier (count-box num-threads mutex cond))

(define (blodwen-make-barrier num-threads)
  (make-barrier (box 0) num-threads (make-mutex) (make-condition)))

(define (blodwen-barrier-wait barrier)
  (let [(count-box (barrier-count-box barrier))
        (num-threads (barrier-num-threads barrier))
        (mutex (barrier-mutex barrier))
        (condition (barrier-cond barrier))]
    (with-mutex mutex
    (let* [(count-old (unbox count-box))
           (count-new (+ count-old 1))]
      (set-box! count-box count-new)
      (if (= count-new num-threads)
          (condition-broadcast condition)
          (condition-wait condition mutex))
      ))))

;; Channel
; With thanks to Alain Zscheile (@zseri) for help with understanding condition
; variables, and figuring out where the problems were and how to solve them.

(define-record channel (read-mut read-cv read-box val-cv val-box))

(define (blodwen-make-channel ty)
  (make-channel
    (make-mutex)
    (make-condition)
    (box #t)
    (make-condition)
    (box '())
    ))

; block on the read status using read-cv until the value has been read
(define (channel-put-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [read-cv  (channel-read-cv  chan)]
        )
    (if (unbox read-box)
      (void)    ; val has been read, so everything is fine
      (begin    ; otherwise, block/spin with cv
        (condition-wait read-cv read-mut)
        (channel-put-while-helper chan)
        )
      )))

(define (blodwen-channel-put ty chan val)
  (with-mutex (channel-read-mut chan)
    (channel-put-while-helper chan)
    (let ([read-box (channel-read-box chan)]
          [val-box  (channel-val-box  chan)]
          )
      (set-box! val-box val)
      (set-box! read-box #f)
      ))
  (condition-signal (channel-val-cv chan))
  )

; block on the value until it has been set
(define (channel-get-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [val-cv   (channel-val-cv   chan)]
        )
    (if (unbox read-box)
      (begin
        (condition-wait val-cv read-mut)
        (channel-get-while-helper chan)
        )
      (void)
      )))

(define (blodwen-channel-get ty chan)
  (mutex-acquire (channel-read-mut chan))
  (channel-get-while-helper chan)
  (let* ([val-box  (channel-val-box  chan)]
         [read-box (channel-read-box chan)]
         [read-cv  (channel-read-cv  chan)]
         [the-val  (unbox val-box)]
         )
    (set-box! val-box '())
    (set-box! read-box #t)
    (mutex-release (channel-read-mut chan))
    (condition-signal read-cv)
    the-val))

(define (blodwen-channel-get-non-blocking ty chan)
  (if (mutex-acquire (channel-read-mut chan) #f)
    (let* ([val-box  (channel-val-box  chan)]
           [read-box (channel-read-box chan)]
           [read-cv  (channel-read-cv  chan)]
           [the-val  (unbox val-box)]
          )
      (if (null? the-val)
          (begin
           (mutex-release (channel-read-mut chan))
           '())
          (begin
            (set-box! val-box '())
            (set-box! read-box #t)
            (mutex-release (channel-read-mut chan))
            (condition-signal read-cv)
            (box the-val))
      ))
  '()))

(define (blodwen-channel-get-with-timeout ty chan timeout)
  ;; timeout is in milliseconds, convert to nanoseconds
  (let* ([timeout-ns (* timeout 1000000)]
         [sleep-ns 10000] ; 10 us step
         [sleep-time (make-time 'time-duration (mod sleep-ns 1000000000)
                                                (div sleep-ns 1000000000))])
    (let loop ([elapsed 0])
      (if (mutex-acquire (channel-read-mut chan) #f)
          (let* ([val-box  (channel-val-box chan)]
                 [the-val  (unbox val-box)])
            (if (null? the-val)
                (if (>= elapsed timeout-ns)
                    (begin
                      (mutex-release (channel-read-mut chan))
                      '())
                    (begin
                      (mutex-release (channel-read-mut chan))
                      (sleep sleep-time)
                      (loop (+ elapsed sleep-ns))))
                (let* ([read-box (channel-read-box chan)]
                       [read-cv  (channel-read-cv chan)])
                  (set-box! val-box '())
                  (set-box! read-box #t)
                  (mutex-release (channel-read-mut chan))
                  (condition-signal read-cv)
                  (box the-val))))
          (begin
            (sleep sleep-time)
            (loop (+ elapsed sleep-ns)))))))

;; Mutex

(define (blodwen-make-mutex)
  (make-mutex))
(define (blodwen-mutex-acquire mutex)
  (mutex-acquire mutex))
(define (blodwen-mutex-release mutex)
  (mutex-release mutex))

;; Condition variable

(define (blodwen-make-condition)
  (make-condition))
(define (blodwen-condition-wait condition mutex)
  (condition-wait condition mutex))
(define (blodwen-condition-wait-timeout condition mutex timeout)
  (let* [(sec (div timeout 1000000))
         (micro (mod timeout 1000000))]
    (condition-wait condition mutex (make-time 'time-duration (* 1000 micro) sec))))
(define (blodwen-condition-signal condition)
  (condition-signal condition))
(define (blodwen-condition-broadcast condition)
  (condition-broadcast condition))

;; Future

(define-record future-internal (result ready mutex signal))
(define (blodwen-make-future ty work)
  (let ([future (make-future-internal #f #f (make-mutex) (make-condition))])
    (fork-thread (lambda ()
      (let ([result (work '())])
        (with-mutex (future-internal-mutex future)
          (set-future-internal-result! future result)
          (set-future-internal-ready! future #t)
          (condition-broadcast (future-internal-signal future))))))
    future))
(define (blodwen-await-future ty future)
  (let ([mutex (future-internal-mutex future)])
    (with-mutex mutex
      (if (not (future-internal-ready future))
          (condition-wait (future-internal-signal future) mutex))
      (future-internal-result future))))

(define (blodwen-sleep s) (sleep (make-time 'time-duration 0 s)))
(define (blodwen-usleep s)
  (let ((sec (div s 1000000))
        (micro (mod s 1000000)))
       (sleep (make-time 'time-duration (* 1000 micro) sec))))

(define (blodwen-clock-time-utc) (current-time 'time-utc))
(define (blodwen-clock-time-monotonic) (current-time 'time-monotonic))
(define (blodwen-clock-time-duration) (current-time 'time-duration))
(define (blodwen-clock-time-process) (current-time 'time-process))
(define (blodwen-clock-time-thread) (current-time 'time-thread))
(define (blodwen-clock-time-gccpu) (current-time 'time-collector-cpu))
(define (blodwen-clock-time-gcreal) (current-time 'time-collector-real))
(define (blodwen-is-time? clk) (if (time? clk) 1 0))
(define (blodwen-clock-second time) (time-second time))
(define (blodwen-clock-nanosecond time) (time-nanosecond time))

(define (blodwen-arg-count)
  (length (command-line)))

(define (blodwen-arg n)
  (if (< n (length (command-line))) (list-ref (command-line) n) ""))

(define (blodwen-hasenv var)
  (if (eq? (getenv var) #f) 0 1))

;; Randoms
(define random-seed-register 0)
(define (initialize-random-seed-once)
  (if (= (virtual-register random-seed-register) 0)
      (let ([seed (time-nanosecond (current-time))])
        (set-virtual-register! random-seed-register seed)
        (random-seed seed))))

(define (blodwen-random-seed seed)
  (set-virtual-register! random-seed-register seed)
  (random-seed seed))
(define blodwen-random
  (case-lambda
    ;; no argument, pick a real value from [0, 1.0)
    [() (begin
          (initialize-random-seed-once)
          (random 1.0))]
    ;; single argument k, pick an integral value from [0, k)
    [(k)
      (begin
        (initialize-random-seed-once)
        (if (> k 0)
              (random k)
              (assertion-violationf 'blodwen-random "invalid range argument ~a" k)))]))

;; For finalisers

(define blodwen-finaliser (make-guardian))
(define (blodwen-register-object obj proc)
  (let [(x (cons obj proc))]
       (blodwen-finaliser x)
       x))
(define blodwen-run-finalisers
  (lambda ()
    (let run ()
      (let ([x (blodwen-finaliser)])
        (when x
          (((cdr x) (car x)) 'erased)
          (run))))))

;; For creating and reading back scheme objects

; read a scheme string and evaluate it, returning 'Just result' on success
; TODO: catch exception!
(define (blodwen-eval-scheme str)
  (guard
     (x [#t '()]) ; Nothing on failure
     (box (eval (read (open-input-string str)))))
  ); box == Just

(define (blodwen-eval-okay obj)
  (if (null? obj)
      0
      1))

(define (blodwen-get-eval-result obj)
  (unbox obj))

(define (blodwen-debug-scheme obj)
  (display obj) (newline))

(define (blodwen-is-number obj)
  (if (number? obj) 1 0))

(define (blodwen-is-integer obj)
  (if (and (number? obj) (exact? obj)) 1 0))

(define (blodwen-is-float obj)
  (if (flonum? obj) 1 0))

(define (blodwen-is-char obj)
  (if (char? obj) 1 0))

(define (blodwen-is-string obj)
  (if (string? obj) 1 0))

(define (blodwen-is-procedure obj)
  (if (procedure? obj) 1 0))

(define (blodwen-is-symbol obj)
  (if (symbol? obj) 1 0))

(define (blodwen-is-vector obj)
  (if (vector? obj) 1 0))

(define (blodwen-is-nil obj)
  (if (null? obj) 1 0))

(define (blodwen-is-pair obj)
  (if (pair? obj) 1 0))

(define (blodwen-is-box obj)
  (if (box? obj) 1 0))

(define (blodwen-make-symbol str)
  (string->symbol str))

; The below rely on checking that the objects are the right type first.

(define (blodwen-vector-ref obj i)
  (vector-ref obj i))

(define (blodwen-vector-length obj)
  (vector-length obj))

(define (blodwen-vector-list obj)
  (vector->list obj))

(define (blodwen-unbox obj)
  (unbox obj))

(define (blodwen-apply obj arg)
  (obj arg))

(define (blodwen-force obj)
  (obj))

(define (blodwen-read-symbol sym)
  (symbol->string sym))

(define (blodwen-id x) x)
(define PreludeC-45Types-fastUnpack (lambda (farg-0) (string-unpack farg-0)))
(define PreludeC-45Types-fastPack (lambda (farg-0) (string-pack farg-0)))
(define PreludeC-45IO-prim__putStr (lambda (farg-0 farg-1) ((foreign-procedure "idris2_putStr" (string) void) farg-0)))
(define PreludeC-45IO-prim__getString (lambda (farg-0) ((foreign-procedure "idris2_getString" (void*) string) farg-0)))
(define PreludeC-45IO-prim__getStr (lambda (farg-0) ((foreign-procedure "idris2_getStr" () string) )))
(define PrimIO-prim__nullAnyPtr (lambda (farg-0) ((foreign-procedure "idris2_isNull" (void*) int) farg-0)))
(define SystemC-45FileC-45ReadWrite-prim__readLine (lambda (farg-0 farg-1) ((foreign-procedure "idris2_readLine" (void*) void*) farg-0)))
(define SystemC-45FileC-45ReadWrite-prim__eof (lambda (farg-0 farg-1) ((foreign-procedure "idris2_eof" (void*) int) farg-0)))
(define SystemC-45FFI-prim__free (lambda (farg-0 farg-1) ((foreign-procedure "idris2_free" (void*) void) farg-0)))
(define SystemC-45FileC-45Error-prim__fileErrno (lambda (farg-0) ((foreign-procedure "idris2_fileErrno" () int) )))
(define SystemC-45FileC-45Error-prim__error (lambda (farg-0 farg-1) ((foreign-procedure "idris2_fileError" (void*) int) farg-0)))
(define SystemC-45Errno-prim__strerror (lambda (farg-0 farg-1) ((foreign-procedure "idris2_strerror" (int) string) farg-0)))
(define SystemC-45FileC-45Handle-prim__open (lambda (farg-0 farg-1 farg-2) ((foreign-procedure "idris2_openFile" (string string) void*) farg-0 farg-1)))
(define SystemC-45FileC-45Handle-prim__close (lambda (farg-0 farg-1) ((foreign-procedure "idris2_closeFile" (void*) void) farg-0)))
(define System-prim__time (lambda (farg-0) ((foreign-procedure "idris2_time" () int) )))
(define System-prim__system (lambda (farg-0 farg-1) ((foreign-procedure "idris2_system" (string) int) farg-0)))
(define PreludeC-45Types-getAt (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) (if (null? arg-2) '() (let ((e-3 (car arg-2))) (box e-3))))(else (let ((e-1 (- arg-1 1))) (if (null? arg-2) '() (let ((e-7 (cdr arg-2))) (PreludeC-45Types-getAt e-1 e-7))))))))
(define PreludeC-45EqOrd-u--C-60C-61_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char<=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-62C-61_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char>=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Types-isDigit (lambda (arg-0) (let ((sc0 (PreludeC-45EqOrd-u--C-62C-61_Ord_Char arg-0 #\0))) (cond ((equal? sc0 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Char arg-0 #\9)) (else 0)))))
(define PreludeC-45Types-prim__integerToNat (lambda (arg-0) (let ((sc0 (or (and (<= 0 arg-0) 1) 0))) (cond ((equal? sc0 0) 0)(else arg-0)))))
(define PreludeC-45Show-firstCharIs (lambda (arg-0 arg-1) (cond ((equal? arg-1 "") 0)(else (arg-0 (string-ref arg-1 0))))))
(define PreludeC-45Show-protectEsc (lambda (arg-0 arg-1 arg-2) (string-append arg-1 (string-append (let ((sc0 (PreludeC-45Show-firstCharIs arg-0 arg-2))) (cond ((equal? sc0 1) "\\&") (else ""))) arg-2))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-62_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char>? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Show-showParens (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) arg-1) (else (string-append "(" (string-append arg-1 ")"))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) 1)(else 0))) ((equal? arg-0 1) (cond ((equal? arg-1 1) 1)(else 0))) ((equal? arg-0 2) (cond ((equal? arg-1 2) 1)(else 0)))(else 0))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define PreludeC-45Show-precCon (lambda (arg-0) (case (vector-ref arg-0 0) ((0) 0) ((1) 1) ((2) 2) ((3) 3) ((4) 4) ((5) 5) (else 6))))
(define PreludeC-45EqOrd-u--C-60_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (< arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--compare_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Integer arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Integer arg-0 arg-1))) (cond ((equal? sc1 1) 1) (else 2))))))))
(define PreludeC-45Show-u--compare_Ord_Prec (lambda (arg-0 arg-1) (case (vector-ref arg-0 0) ((4) (let ((e-0 (vector-ref arg-0 1))) (case (vector-ref arg-1 0) ((4) (let ((e-1 (vector-ref arg-1 1))) (PreludeC-45EqOrd-u--compare_Ord_Integer e-0 e-1)))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))
(define PreludeC-45Show-u--C-62C-61_Ord_Prec (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (PreludeC-45Show-u--compare_Ord_Prec arg-0 arg-1) 0)))
(define PreludeC-45Show-primNumShow (lambda (arg-1 arg-2 arg-3) (let ((u--str (arg-1 arg-3))) (PreludeC-45Show-showParens (let ((sc0 (PreludeC-45Show-u--C-62C-61_Ord_Prec arg-2 (vector 5 )))) (cond ((equal? sc0 1) (PreludeC-45Show-firstCharIs (lambda (arg-0) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-0 #\-)) u--str)) (else 0))) u--str))))
(define PreludeC-45Show-u--showPrec_Show_Int (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Show-u--show_Show_Int (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Int (vector 0 ) arg-0)))
(define PreludeC-45Show-n--2434-11912-u--asciiTab (lambda (arg-0) (cons "NUL" (cons "SOH" (cons "STX" (cons "ETX" (cons "EOT" (cons "ENQ" (cons "ACK" (cons "BEL" (cons "BS" (cons "HT" (cons "LF" (cons "VT" (cons "FF" (cons "CR" (cons "SO" (cons "SI" (cons "DLE" (cons "DC1" (cons "DC2" (cons "DC3" (cons "DC4" (cons "NAK" (cons "SYN" (cons "ETB" (cons "CAN" (cons "EM" (cons "SUB" (cons "ESC" (cons "FS" (cons "GS" (cons "RS" (cons "US" '()))))))))))))))))))))))))))))))))))
(define PreludeC-45Show-showLitChar (lambda (arg-0) (cond ((equal? arg-0 (integer->char 7)) (lambda (arg-1) (string-append "\\a" arg-1))) ((equal? arg-0 (integer->char 8)) (lambda (arg-1) (string-append "\\b" arg-1))) ((equal? arg-0 (integer->char 12)) (lambda (arg-1) (string-append "\\f" arg-1))) ((equal? arg-0 (integer->char 10)) (lambda (arg-1) (string-append "\\n" arg-1))) ((equal? arg-0 (integer->char 13)) (lambda (arg-1) (string-append "\\r" arg-1))) ((equal? arg-0 (integer->char 9)) (lambda (arg-1) (string-append "\\t" arg-1))) ((equal? arg-0 (integer->char 11)) (lambda (arg-1) (string-append "\\v" arg-1))) ((equal? arg-0 (integer->char 14)) (lambda (eta-0) (PreludeC-45Show-protectEsc (lambda (arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-1 #\H)) "\\SO" eta-0))) ((equal? arg-0 (integer->char 127)) (lambda (arg-1) (string-append "\\DEL" arg-1))) ((equal? arg-0 #\\) (lambda (arg-1) (string-append "\\\\" arg-1)))(else (lambda (clam-0) (let ((sc0 (PreludeC-45Types-getAt (PreludeC-45Types-prim__integerToNat (char->integer arg-0)) (PreludeC-45Show-n--2434-11912-u--asciiTab arg-0)))) (if (null? sc0) (let ((sc1 (PreludeC-45EqOrd-u--C-62_Ord_Char arg-0 (integer->char 127)))) (cond ((equal? sc1 1) (string-cons #\\ (PreludeC-45Show-protectEsc (lambda (eta-0) (PreludeC-45Types-isDigit eta-0)) (PreludeC-45Show-u--show_Show_Int (cast-char-boundedInt arg-0 63)) clam-0))) (else (string-cons arg-0 clam-0)))) (let ((e-1 (unbox sc0))) (string-cons #\\ (string-append e-1 clam-0))))))))))
(define PreludeC-45Show-showLitString (lambda (arg-0) (lambda (clam-0) (if (null? arg-0) clam-0 (let ((e-2 (car arg-0))) (let ((e-3 (cdr arg-0))) (cond ((equal? e-2 #\") (string-append "\\\"" ((PreludeC-45Show-showLitString e-3) clam-0)))(else ((PreludeC-45Show-showLitChar e-2) ((PreludeC-45Show-showLitString e-3) clam-0))))))))))
(define PreludeC-45Show-u--show_Show_String (lambda (arg-0) (string-cons #\" ((PreludeC-45Show-showLitString (PreludeC-45Types-fastUnpack arg-0)) "\""))))
(define PreludeC-45Show-u--showPrec_Show_String (lambda (arg-0 arg-1) (PreludeC-45Show-u--show_Show_String arg-1)))
(define csegen-1(delay (cons (lambda (u--x) (PreludeC-45Show-u--show_Show_String u--x)) (lambda (u--d) (lambda (u--x) (PreludeC-45Show-u--showPrec_Show_String u--d u--x))))))
(define csegen-6(delay (lambda (eta-0) (PreludeC-45IO-prim__putStr "  (none)\xa;" eta-0))))
(define PreludeC-45IO-u--map_Functor_IO (lambda (arg-2 arg-3 ext-0) (let ((act-2 (arg-3 ext-0))) (arg-2 act-2))))
(define csegen-13(delay (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8920) (lambda (eta-0) (PreludeC-45IO-u--map_Functor_IO u--func arg-8920 eta-0)))))) (lambda (u--a) (lambda (arg-9959) (lambda (eta-0) arg-9959))) (lambda (u--b) (lambda (u--a) (lambda (arg-9965) (lambda (arg-9972) (lambda (world-4) (let ((act-5 (arg-9965 world-4))) (let ((act-3 (arg-9972 world-4))) (act-5 act-3)))))))))))
(define PreludeC-45Types-u--foldl_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (PreludeC-45Types-u--foldl_Foldable_List arg-2 ((arg-2 arg-3) e-2) e-3))))))
(define PreludeC-45Types-u--foldMap_Foldable_List (lambda (arg-2 arg-3 ext-0) (PreludeC-45Types-u--foldl_Foldable_List (lambda (u--acc) (lambda (u--elem) (let ((e-1 (car arg-2))) ((e-1 u--acc) (arg-3 u--elem))))) (let ((e-2 (cdr arg-2))) e-2) ext-0)))
(define PreludeC-45Basics-flip (lambda (arg-3 ext-0 ext-1) ((arg-3 ext-1) ext-0)))
(define PreludeC-45Types-u--foldlM_Foldable_List (lambda (arg-3 arg-4 arg-5 ext-0) (PreludeC-45Types-u--foldl_Foldable_List (lambda (u--ma) (lambda (u--b) (let ((e-2 (vector-ref arg-3 1))) ((((e-2 'erased) 'erased) u--ma) (lambda (eta-0) (PreludeC-45Basics-flip arg-4 u--b eta-0)))))) (let ((e-1 (vector-ref arg-3 0))) (let ((e-5 (vector-ref e-1 1))) ((e-5 'erased) arg-5))) ext-0)))
(define PreludeC-45Types-u--foldr_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) ((arg-2 e-2) (PreludeC-45Types-u--foldr_Foldable_List arg-2 arg-3 e-3)))))))
(define PreludeC-45Types-u--null_Foldable_List (lambda (arg-1) (if (null? arg-1) 1 0)))
(define csegen-28(delay (vector (lambda (u--acc) (lambda (u--elem) (lambda (u--func) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldr_Foldable_List u--func u--init u--input)))))) (lambda (u--elem) (lambda (u--acc) (lambda (u--func) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldl_Foldable_List u--func u--init u--input)))))) (lambda (u--elem) (lambda (arg-10947) (PreludeC-45Types-u--null_Foldable_List arg-10947))) (lambda (u--elem) (lambda (u--acc) (lambda (u--m) (lambda (i_con-0) (lambda (u--funcM) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldlM_Foldable_List i_con-0 u--funcM u--init u--input)))))))) (lambda (u--elem) (lambda (arg-10976) arg-10976)) (lambda (u--a) (lambda (u--m) (lambda (i_con-0) (lambda (u--f) (lambda (arg-10990) (PreludeC-45Types-u--foldMap_Foldable_List i_con-0 u--f arg-10990)))))))))
(define PreludeC-45Interfaces-C-42C-62 (lambda (arg-3 arg-4 arg-5) (let ((e-3 (vector-ref arg-3 2))) ((((e-3 'erased) 'erased) (((let ((eff-0 (let ((e-6 (vector-ref arg-3 0))) e-6))) ((eff-0 'erased) 'erased)) (lambda (eta-0) (lambda (eta-1) eta-1))) arg-4)) arg-5))))
(define PreludeC-45Interfaces-traverse_ (lambda (arg-4 arg-5 arg-6) (let ((e-1 (vector-ref arg-5 0))) ((((e-1 'erased) 'erased) (lambda (eta-0) (lambda (eta-1) (PreludeC-45Interfaces-C-42C-62 arg-4 (arg-6 eta-0) eta-1)))) (let ((e-8 (vector-ref arg-4 1))) ((e-8 'erased) 'erased))))))
(define DataC-45List-mergeReplicate (lambda (arg-1 arg-2) (if (null? arg-2) '() (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (cons arg-1 (cons e-2 (DataC-45List-mergeReplicate arg-1 e-3))))))))
(define DataC-45List-intersperse (lambda (arg-1 arg-2) (if (null? arg-2) '() (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (cons e-2 (DataC-45List-mergeReplicate arg-1 e-3)))))))
(define DataC-45String-joinBy (lambda (arg-0 arg-1) (PreludeC-45Types-u--foldMap_Foldable_List (cons (lambda (arg-8505) (lambda (arg-8508) (string-append arg-8505 arg-8508))) "") (lambda (eta-0) eta-0) (DataC-45List-intersperse arg-0 arg-1))))
(define REPLC-45Core-u--show_Show_ConstraintType (lambda (arg-0) (cond ((equal? arg-0 0) "PRIMARY KEY") ((equal? arg-0 1) "FOREIGN KEY") ((equal? arg-0 2) "UNIQUE") ((equal? arg-0 3) "CHECK") (else "NOT NULL"))))
(define REPLC-45Core-u--show_Show_Constraint (lambda (arg-0) (string-append (let ((e-0 (vector-ref arg-0 0))) e-0) (string-append " " (string-append (REPLC-45Core-u--show_Show_ConstraintType (let ((e-1 (vector-ref arg-0 1))) e-1)) (string-append " on " (string-append (let ((e-2 (vector-ref arg-0 2))) e-2) (string-append " (" (string-append (DataC-45String-joinBy ", " (let ((e-3 (vector-ref arg-0 3))) e-3)) ")")))))))))
(define csegen-30(delay (PreludeC-45Interfaces-traverse_ (force csegen-13) (force csegen-28) (lambda (u--c) (lambda (eta-0) (PreludeC-45IO-prim__putStr (string-append (string-append "  " (REPLC-45Core-u--show_Show_Constraint u--c)) "\xa;") eta-0))))))
(define PreludeC-45EqOrd-u--C-60_Ord_Double (lambda (arg-0 arg-1) (let ((sc0 (or (and (< arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Show-u--showPrec_Show_Double (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Show-u--show_Show_Double (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Double (vector 0 ) arg-0)))
(define REPLC-45Core-u--show_Show_FunctionalDep (lambda (arg-0) (string-append (let ((e-0 (vector-ref arg-0 0))) e-0) (string-append ": {" (string-append (DataC-45String-joinBy ", " (let ((e-1 (vector-ref arg-0 1))) e-1)) (string-append "} -> {" (string-append (DataC-45String-joinBy ", " (let ((e-2 (vector-ref arg-0 2))) e-2)) (string-append "}" (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Double (let ((e-3 (vector-ref arg-0 3))) e-3) 1.0))) (cond ((equal? sc0 1) (string-append " [confidence: " (string-append (PreludeC-45Show-u--show_Show_Double (let ((e-3 (vector-ref arg-0 3))) e-3)) "]"))) (else "")))))))))))
(define csegen-33(delay (PreludeC-45Interfaces-traverse_ (force csegen-13) (force csegen-28) (lambda (u--fd) (lambda (eta-0) (PreludeC-45IO-prim__putStr (string-append (string-append "  " (REPLC-45Core-u--show_Show_FunctionalDep u--fd)) "\xa;") eta-0))))))
(define csegen-42 (cons (vector (force csegen-13) (lambda (u--b) (lambda (u--a) (lambda (arg-10444) (lambda (arg-10447) (lambda (world-0) (let ((act-1 (arg-10444 world-0))) ((arg-10447 act-1) world-0))))))) (lambda (u--a) (lambda (arg-10458) (lambda (world-0) (let ((act-1 (arg-10458 world-0))) (act-1 world-0)))))) (lambda (u--a) (lambda (arg-13076) arg-13076))))
(define PreludeC-45InterfacesC-45BoolC-45Semigroup-u--C-60C-43C-62_Semigroup_AnyBool (lambda (arg-0 arg-1) (cond ((equal? arg-0 1) 1) (else arg-1))))
(define csegen-99 (cons (lambda (arg-8505) (lambda (arg-8508) (PreludeC-45InterfacesC-45BoolC-45Semigroup-u--C-60C-43C-62_Semigroup_AnyBool arg-8505 arg-8508))) 0))
(define u--prim__sub_Integer (lambda (arg-0 arg-1) (- arg-0 arg-1)))
(define REPLC-45Core-initialState (vector 0 '() '() '() '() '()))
(define DataC-45String-strM (lambda (arg-0) (cond ((equal? arg-0 "") '())(else (cons (string-ref arg-0 0) (substring arg-0 1 (string-length arg-0)))))))
(define DataC-45String-with--asList-9700 (lambda (arg-0 arg-1) (cond ((equal? arg-0 "") (if (null? arg-1) (vector 0 ) (let ((e-0 (car arg-1))) (let ((e-1 (cdr arg-1))) (vector 1 e-0 e-1 (lambda () (DataC-45String-asList e-1)))))))(else (let ((e-0 (car arg-1))) (let ((e-1 (cdr arg-1))) (vector 1 e-0 e-1 (lambda () (DataC-45String-asList e-1)))))))))
(define DataC-45String-asList (lambda (arg-0) (DataC-45String-with--asList-9700 arg-0 (DataC-45String-strM arg-0))))
(define PreludeC-45Types-isSpace (lambda (arg-0) (cond ((equal? arg-0 #\ ) 1) ((equal? arg-0 (integer->char 9)) 1) ((equal? arg-0 (integer->char 13)) 1) ((equal? arg-0 (integer->char 10)) 1) ((equal? arg-0 (integer->char 12)) 1) ((equal? arg-0 (integer->char 11)) 1) ((equal? arg-0 (integer->char 160)) 1)(else 0))))
(define DataC-45String-with--ltrim-9724 (lambda (arg-0 arg-1) (cond ((equal? arg-0 "") (case (vector-ref arg-1 0) ((0) "")(else (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (vector-ref arg-1 2))) (let ((e-2 (vector-ref arg-1 3))) (let ((u--str (string-cons e-0 e-1))) (let ((sc2 (PreludeC-45Types-isSpace e-0))) (cond ((equal? sc2 1) (DataC-45String-with--ltrim-9724 e-1 (e-2))) (else u--str))))))))))(else (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (vector-ref arg-1 2))) (let ((e-2 (vector-ref arg-1 3))) (let ((u--str (string-cons e-0 e-1))) (let ((sc1 (PreludeC-45Types-isSpace e-0))) (cond ((equal? sc1 1) (DataC-45String-with--ltrim-9724 e-1 (e-2))) (else u--str)))))))))))
(define DataC-45String-ltrim (lambda (arg-0) (DataC-45String-with--ltrim-9724 arg-0 (DataC-45String-asList arg-0))))
(define DataC-45String-trim (lambda (ext-0) (DataC-45String-ltrim (string-reverse (DataC-45String-ltrim (string-reverse ext-0))))))
(define SystemC-45FileC-45Handle-closeFile (lambda (arg-1 arg-2) (let ((e-2 (cdr arg-1))) ((e-2 'erased) (lambda (eta-0) (SystemC-45FileC-45Handle-prim__close arg-2 eta-0))))))
(define PreludeC-45Types-elemBy (lambda (arg-2 arg-3 arg-4) (let ((e-6 (vector-ref arg-2 5))) ((((e-6 'erased) 'erased) csegen-99) (arg-3 arg-4)))))
(define PreludeC-45Types-elem (lambda (arg-2 arg-3 ext-0) (PreludeC-45Types-elemBy arg-2 (let ((e-1 (car arg-3))) e-1) ext-0)))
(define SystemC-45Info-os (blodwen-os))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (or (and (string=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define SystemC-45Info-isWindows ((PreludeC-45Types-elem (force csegen-28) (cons (lambda (arg-712) (lambda (arg-715) (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-712 arg-715))) (lambda (arg-722) (lambda (arg-725) (PreludeC-45EqOrd-u--C-47C-61_Eq_String arg-722 arg-725)))) SystemC-45Info-os) (cons "windows" (cons "mingw32" (cons "cygwin32" '())))))
(define SystemC-45FileC-45Mode-modeStr (lambda (arg-0) (cond ((equal? arg-0 0) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "rb") (else "r")))) ((equal? arg-0 1) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "wb") (else "w")))) ((equal? arg-0 2) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "ab") (else "a")))) ((equal? arg-0 3) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "rb+") (else "r+")))) ((equal? arg-0 4) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "wb+") (else "w+")))) (else (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "ab+") (else "a+")))))))
(define SystemC-45FileC-45Support-ok (lambda (arg-3 arg-4) (let ((e-1 (car arg-3))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) (vector 1 arg-4)))))))
(define SystemC-45FileC-45Error-returnError (lambda (arg-2) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-2))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45Error-prim__fileErrno eta-0))))) (lambda (u--err) (let ((e-7 (car arg-2))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (vector 0 (cond ((equal? u--err 0) (vector 1 )) ((equal? u--err 1) (vector 2 )) ((equal? u--err 2) (vector 3 )) ((equal? u--err 3) (vector 4 )) ((equal? u--err 4) (vector 5 ))(else (vector 0 (bs- u--err 5 63)))))))))))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Int (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Int (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define SystemC-45FileC-45Handle-openFile (lambda (arg-1 arg-2 arg-3) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45Handle-prim__open arg-2 (SystemC-45FileC-45Mode-modeStr arg-3) eta-0))))) (lambda (u--res) (let ((sc1 (PreludeC-45EqOrd-u--C-47C-61_Eq_Int (PrimIO-prim__nullAnyPtr u--res) (blodwen-toSignedInt 0 63)))) (cond ((equal? sc1 1) (SystemC-45FileC-45Error-returnError arg-1)) (else (SystemC-45FileC-45Support-ok arg-1 u--res))))))))))
(define SystemC-45FileC-45ReadWrite-fEOF (lambda (arg-1 arg-2) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45ReadWrite-prim__eof arg-2 eta-0))))) (lambda (u--res) (let ((e-7 (car arg-1))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (PreludeC-45EqOrd-u--C-47C-61_Eq_Int u--res (blodwen-toSignedInt 0 63))))))))))))
(define SystemC-45FileC-45Error-fileError (lambda (arg-1 arg-2) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45Error-prim__error arg-2 eta-0))))) (lambda (u--x) (let ((e-7 (car arg-1))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (PreludeC-45EqOrd-u--C-47C-61_Eq_Int u--x (blodwen-toSignedInt 0 63))))))))))))
(define SystemC-45FFI-free (lambda (arg-1 arg-2) (let ((e-2 (cdr arg-1))) ((e-2 'erased) (lambda (eta-0) (SystemC-45FFI-prim__free arg-2 eta-0))))))
(define PreludeC-45InterfacesC-45Applicative-u--pure_Applicative_ComposeC-40C-40C-46C-32C-36fC-41C-32C-36gC-41 (lambda (arg-3 arg-4 ext-0) (let ((e-2 (vector-ref arg-3 1))) ((e-2 'erased) (let ((e-5 (vector-ref arg-4 1))) ((e-5 'erased) ext-0))))))
(define SystemC-45FileC-45ReadWrite-getStringAndFree (lambda (arg-1 arg-2 arg-3) (let ((sc0 (PreludeC-45EqOrd-u--C-47C-61_Eq_Int (PrimIO-prim__nullAnyPtr arg-3) (blodwen-toSignedInt 0 63)))) (cond ((equal? sc0 1) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (SystemC-45FileC-45Error-fileError arg-1 arg-2)) (lambda (bind-0) (cond ((equal? bind-0 1) (SystemC-45FileC-45Error-returnError arg-1)) (else (PreludeC-45InterfacesC-45Applicative-u--pure_Applicative_ComposeC-40C-40C-46C-32C-36fC-41C-32C-36gC-41 (let ((e-7 (car arg-1))) (let ((e-10 (vector-ref e-7 0))) e-10)) (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8920) (case (vector-ref arg-8920 0) ((0) (let ((e-6 (vector-ref arg-8920 1))) (vector 0 e-6))) (else (let ((e-6 (vector-ref arg-8920 1))) (vector 1 (u--func e-6))))))))) (lambda (u--a) (lambda (arg-9959) (vector 1 arg-9959))) (lambda (u--b) (lambda (u--a) (lambda (arg-9965) (lambda (arg-9972) (case (vector-ref arg-9965 0) ((0) (let ((e-6 (vector-ref arg-9965 1))) (vector 0 e-6))) (else (let ((e-6 (vector-ref arg-9965 1))) (case (vector-ref arg-9972 0) ((1) (let ((e-8 (vector-ref arg-9972 1))) (vector 1 (e-6 e-8)))) (else (let ((e-11 (vector-ref arg-9972 1))) (vector 0 e-11)))))))))))) "")))))))) (else (let ((u--s (PreludeC-45IO-prim__getString arg-3))) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (SystemC-45FFI-free arg-1 arg-3)) (lambda (_-10685) (SystemC-45FileC-45Support-ok arg-1 u--s)))))))))))
(define SystemC-45FileC-45ReadWrite-fGetLine (lambda (arg-1 arg-2) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45ReadWrite-prim__readLine arg-2 eta-0))))) (lambda (u--res) (SystemC-45FileC-45ReadWrite-getStringAndFree arg-1 arg-2 u--res)))))))
(define REPLC-45Core-n--7489-8648-u--readAll (lambda (arg-0 arg-1 ext-0) (let ((act-1 ((SystemC-45FileC-45ReadWrite-fEOF csegen-42 arg-1) ext-0))) (cond ((equal? act-1 0) (let ((act-2 ((SystemC-45FileC-45ReadWrite-fGetLine csegen-42 arg-1) ext-0))) (case (vector-ref act-2 0) ((1) (let ((e-2 (vector-ref act-2 1))) (let ((act-3 (REPLC-45Core-n--7489-8648-u--readAll arg-0 arg-1 ext-0))) (string-append e-2 act-3)))) (else "")))) (else "")))))
(define REPLC-45Core-readFileContents (lambda (arg-0 ext-0) (let ((act-1 ((SystemC-45FileC-45Handle-openFile csegen-42 arg-0 0) ext-0))) (case (vector-ref act-1 0) ((1) (let ((e-2 (vector-ref act-1 1))) (let ((act-2 (REPLC-45Core-n--7489-8648-u--readAll arg-0 e-2 ext-0))) (let ((act-3 ((SystemC-45FileC-45Handle-closeFile csegen-42 e-2) ext-0))) (vector 1 act-2))))) (else (let ((e-5 (vector-ref act-1 1))) (vector 0 e-5)))))))
(define System-system (lambda (arg-1 arg-2) (let ((e-2 (cdr arg-1))) ((e-2 'erased) (lambda (eta-0) (System-prim__system arg-2 eta-0))))))
(define System-time (lambda (arg-1) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (System-prim__time eta-0))))) (lambda (bind-0) (let ((e-7 (car arg-1))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) bind-0))))))))))
(define PreludeC-45Show-u--showPrec_Show_Integer (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Show-u--show_Show_Integer (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Integer (vector 0 ) arg-0)))
(define REPLC-45Core-tmpFilePath (lambda (ext-0) (let ((act-1 ((System-time csegen-42) ext-0))) (string-append "/tmp/fdb-ipc-" (string-append (PreludeC-45Show-u--show_Show_Integer act-1) ".json")))))
(define DataC-45String-unwords (lambda (ext-0) (DataC-45String-joinBy " " ext-0)))
(define PrimIO-unsafeCreateWorld (lambda (arg-1) (arg-1 #f)))
(define PrimIO-unsafePerformIO (lambda (arg-1) (PrimIO-unsafeCreateWorld (lambda (u--w) (arg-1 u--w)))))
(define SystemC-45Errno-strerror (lambda (arg-0) (PrimIO-unsafePerformIO (lambda (eta-0) (SystemC-45Errno-prim__strerror arg-0 eta-0)))))
(define SystemC-45FileC-45Error-u--show_Show_FileError (lambda (arg-0) (case (vector-ref arg-0 0) ((0) (let ((e-0 (vector-ref arg-0 1))) (SystemC-45Errno-strerror e-0))) ((1) "File Read Error") ((2) "File Write Error") ((3) "File Not Found") ((4) "Permission Denied") (else "File Exists"))))
(define REPLC-45Core-execCliCommand (lambda (arg-0 ext-0) (let ((act-1 (REPLC-45Core-tmpFilePath ext-0))) (let ((u--cmd (string-append "fdb-debug " (string-append (DataC-45String-unwords arg-0) (string-append " > " (string-append act-1 " 2>&1")))))) (let ((act-2 ((System-system csegen-42 u--cmd) ext-0))) (let ((sc0 (PreludeC-45EqOrd-u--C-47C-61_Eq_Int act-2 (blodwen-toSignedInt 0 63)))) (cond ((equal? sc0 1) (let ((act-3 (REPLC-45Core-readFileContents act-1 ext-0))) (case (vector-ref act-3 0) ((1) (let ((e-2 (vector-ref act-3 1))) (let ((act-4 ((System-system csegen-42 (string-append "rm -f " act-1)) ext-0))) (vector 0 e-2)))) (else (vector 0 (string-append "Command failed with exit code " (PreludeC-45Show-u--show_Show_Int act-2))))))) (else (let ((act-3 (REPLC-45Core-readFileContents act-1 ext-0))) (case (vector-ref act-3 0) ((1) (let ((e-2 (vector-ref act-3 1))) (let ((act-4 ((System-system csegen-42 (string-append "rm -f " act-1)) ext-0))) (vector 1 e-2)))) (else (let ((e-5 (vector-ref act-3 1))) (vector 0 (string-append "Failed to read output: " (SystemC-45FileC-45Error-u--show_Show_FileError e-5)))))))))))))))
(define DataC-45List-isPrefixOfBy (lambda (arg-2 arg-3 arg-4) (if (null? arg-3) 1 (if (null? arg-4) 0 (let ((e-1 (car arg-3))) (let ((e-2 (cdr arg-3))) (let ((e-4 (car arg-4))) (let ((e-5 (cdr arg-4))) (let ((sc4 ((arg-2 e-1) e-4))) (cond ((equal? sc4 1) (DataC-45List-isPrefixOfBy arg-2 e-2 e-5)) (else 0)))))))))))
(define DataC-45List-tails (lambda (arg-1) (cons arg-1 (if (null? arg-1) '() (let ((e-3 (cdr arg-1))) (DataC-45List-tails e-3))))))
(define DataC-45List-isInfixOfBy (lambda (arg-2 arg-3 arg-4) (PreludeC-45Types-u--foldMap_Foldable_List csegen-99 (lambda (eta-0) (DataC-45List-isPrefixOfBy arg-2 arg-3 eta-0)) (DataC-45List-tails arg-4))))
(define DataC-45List-isInfixOf (lambda (arg-1 ext-0 ext-1) (DataC-45List-isInfixOfBy (let ((e-1 (car arg-1))) e-1) ext-0 ext-1)))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Char (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define DataC-45String-isInfixOf (lambda (arg-0 arg-1) (DataC-45List-isInfixOf (cons (lambda (arg-712) (lambda (arg-715) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-712 arg-715))) (lambda (arg-722) (lambda (arg-725) (PreludeC-45EqOrd-u--C-47C-61_Eq_Char arg-722 arg-725)))) (PreludeC-45Types-fastUnpack arg-0) (PreludeC-45Types-fastUnpack arg-1))))
(define DataC-45List-drop (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) arg-2)(else (let ((e-0 (- arg-1 1))) (if (null? arg-2) '() (let ((e-4 (cdr arg-2))) (DataC-45List-drop e-0 e-4))))))))
(define PreludeC-45TypesC-45List-lengthPlus (lambda (arg-1 arg-2) (if (null? arg-2) arg-1 (let ((e-3 (cdr arg-2))) (PreludeC-45TypesC-45List-lengthPlus (+ arg-1 1) e-3)))))
(define PreludeC-45TypesC-45List-lengthTR (lambda (ext-0) (PreludeC-45TypesC-45List-lengthPlus 0 ext-0)))
(define REPLC-45Core-n--5890-7133-u--skipWs (lambda (arg-0 arg-1 arg-2) (if (null? arg-2) '() (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (let ((sc1 (let ((sc2 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-2 #\ ))) (cond ((equal? sc2 1) 1) (else (let ((sc3 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-2 (integer->char 10)))) (cond ((equal? sc3 1) 1) (else (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-2 (integer->char 9)))))))))) (cond ((equal? sc1 1) (REPLC-45Core-n--5890-7133-u--skipWs arg-0 arg-1 e-3)) (else (cons e-2 e-3)))))))))
(define REPLC-45Core-n--5890-7131-u--extractBoolValue (lambda (arg-0 arg-1 arg-2) (let ((sc0 (REPLC-45Core-n--5890-7133-u--skipWs arg-0 arg-1 arg-2))) (if (null? sc0) '() (let ((e-1 (car sc0))) (let ((e-2 (cdr sc0))) (cond ((equal? e-1 #\t) (if (null? e-2) '() (let ((e-4 (car e-2))) (let ((e-5 (cdr e-2))) (cond ((equal? e-4 #\r) (if (null? e-5) '() (let ((e-7 (car e-5))) (let ((e-8 (cdr e-5))) (cond ((equal? e-7 #\u) (if (null? e-8) '() (let ((e-10 (car e-8))) (cond ((equal? e-10 #\e) (box 1))(else '())))))(else '()))))))(else '())))))) ((equal? e-1 #\f) (if (null? e-2) '() (let ((e-13 (car e-2))) (let ((e-14 (cdr e-2))) (cond ((equal? e-13 #\a) (if (null? e-14) '() (let ((e-16 (car e-14))) (let ((e-17 (cdr e-14))) (cond ((equal? e-16 #\l) (if (null? e-17) '() (let ((e-19 (car e-17))) (let ((e-20 (cdr e-17))) (cond ((equal? e-19 #\s) (if (null? e-20) '() (let ((e-22 (car e-20))) (cond ((equal? e-22 #\e) (box 0))(else '())))))(else '()))))))(else '()))))))(else '()))))))(else '()))))))))
(define REPLC-45Core-n--5890-7134-u--startsWith (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-2) 1 (if (null? arg-3) 0 (let ((e-1 (car arg-2))) (let ((e-2 (cdr arg-2))) (let ((e-4 (car arg-3))) (let ((e-5 (cdr arg-3))) (let ((sc4 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-1 e-4))) (cond ((equal? sc4 1) (REPLC-45Core-n--5890-7134-u--startsWith arg-0 arg-1 e-2 e-5)) (else 0)))))))))))
(define REPLC-45Core-n--5890-7132-u--findAndExtractBool (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-3) '() (let ((e-2 (car arg-3))) (let ((e-3 (cdr arg-3))) (let ((sc1 (REPLC-45Core-n--5890-7134-u--startsWith arg-0 arg-1 arg-2 (cons e-2 e-3)))) (cond ((equal? sc1 1) (REPLC-45Core-n--5890-7131-u--extractBoolValue arg-0 arg-1 (DataC-45List-drop (PreludeC-45TypesC-45List-lengthTR arg-2) (cons e-2 e-3)))) (else (REPLC-45Core-n--5890-7132-u--findAndExtractBool arg-0 arg-1 arg-2 e-3)))))))))
(define REPLC-45Core-extractJsonBool (lambda (arg-0 arg-1) (let ((u--pattern (string-append "\"" (string-append arg-0 "\":")))) (let ((u--chars (PreludeC-45Types-fastUnpack arg-1))) (REPLC-45Core-n--5890-7132-u--findAndExtractBool arg-1 arg-0 (PreludeC-45Types-fastUnpack u--pattern) u--chars)))))
(define REPLC-45Core-n--5645-6904-u--skipWs (lambda (arg-0 arg-1 arg-2) (if (null? arg-2) '() (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (let ((sc1 (let ((sc2 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-2 #\ ))) (cond ((equal? sc2 1) 1) (else (let ((sc3 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-2 (integer->char 10)))) (cond ((equal? sc3 1) 1) (else (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-2 (integer->char 9)))))))))) (cond ((equal? sc1 1) (REPLC-45Core-n--5645-6904-u--skipWs arg-0 arg-1 e-3)) (else (cons e-2 e-3)))))))))
(define PreludeC-45TypesC-45List-reverseOnto (lambda (arg-1 arg-2) (if (null? arg-2) arg-1 (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (PreludeC-45TypesC-45List-reverseOnto (cons e-2 arg-1) e-3))))))
(define PreludeC-45TypesC-45List-reverse (lambda (ext-0) (PreludeC-45TypesC-45List-reverseOnto '() ext-0)))
(define REPLC-45Core-n--5645-6906-u--takeUntilQuote (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-2) (PreludeC-45TypesC-45List-reverse arg-3) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (cond ((equal? e-2 #\") (PreludeC-45TypesC-45List-reverse arg-3)) ((equal? e-2 #\\) (if (null? e-3) (REPLC-45Core-n--5645-6906-u--takeUntilQuote arg-0 arg-1 e-3 (cons e-2 arg-3)) (let ((e-5 (car e-3))) (let ((e-6 (cdr e-3))) (REPLC-45Core-n--5645-6906-u--takeUntilQuote arg-0 arg-1 e-6 (cons e-5 arg-3))))))(else (REPLC-45Core-n--5645-6906-u--takeUntilQuote arg-0 arg-1 e-3 (cons e-2 arg-3)))))))))
(define REPLC-45Core-n--5645-6902-u--extractValue (lambda (arg-0 arg-1 arg-2) (let ((sc0 (REPLC-45Core-n--5645-6904-u--skipWs arg-0 arg-1 arg-2))) (if (null? sc0) '() (let ((e-1 (car sc0))) (let ((e-2 (cdr sc0))) (cond ((equal? e-1 #\") (box (PreludeC-45Types-fastPack (REPLC-45Core-n--5645-6906-u--takeUntilQuote arg-0 arg-1 e-2 '()))))(else '()))))))))
(define REPLC-45Core-n--5645-6905-u--startsWith (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-2) 1 (if (null? arg-3) 0 (let ((e-1 (car arg-2))) (let ((e-2 (cdr arg-2))) (let ((e-4 (car arg-3))) (let ((e-5 (cdr arg-3))) (let ((sc4 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-1 e-4))) (cond ((equal? sc4 1) (REPLC-45Core-n--5645-6905-u--startsWith arg-0 arg-1 e-2 e-5)) (else 0)))))))))))
(define REPLC-45Core-n--5645-6903-u--findAndExtract (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-3) '() (let ((e-2 (car arg-3))) (let ((e-3 (cdr arg-3))) (let ((sc1 (REPLC-45Core-n--5645-6905-u--startsWith arg-0 arg-1 arg-2 (cons e-2 e-3)))) (cond ((equal? sc1 1) (REPLC-45Core-n--5645-6902-u--extractValue arg-0 arg-1 (DataC-45List-drop (PreludeC-45TypesC-45List-lengthTR arg-2) (cons e-2 e-3)))) (else (REPLC-45Core-n--5645-6903-u--findAndExtract arg-0 arg-1 arg-2 e-3)))))))))
(define REPLC-45Core-extractJsonValue (lambda (arg-0 arg-1) (let ((u--pattern (string-append "\"" (string-append arg-0 "\":")))) (let ((u--chars (PreludeC-45Types-fastUnpack arg-1))) (REPLC-45Core-n--5645-6903-u--findAndExtract arg-1 arg-0 (PreludeC-45Types-fastUnpack u--pattern) u--chars)))))
(define PreludeC-45TypesC-45SnocList-C-60C-62C-62 (lambda (arg-1 arg-2) (if (null? arg-1) arg-2 (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 e-2 (cons e-3 arg-2)))))))
(define PreludeC-45TypesC-45List-mapMaybeAppend (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-2 '()) (let ((e-1 (car arg-4))) (let ((e-2 (cdr arg-4))) (let ((sc1 (arg-3 e-1))) (if (null? sc1) (PreludeC-45TypesC-45List-mapMaybeAppend arg-2 arg-3 e-2) (let ((e-3 (unbox sc1))) (PreludeC-45TypesC-45List-mapMaybeAppend (cons arg-2 e-3) arg-3 e-2)))))))))
(define REPLC-45Core-n--6145-7373-u--extractString (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-2) (cons (PreludeC-45Types-fastPack (PreludeC-45TypesC-45List-reverse arg-3)) '()) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (cond ((equal? e-2 #\") (cons (PreludeC-45Types-fastPack (PreludeC-45TypesC-45List-reverse arg-3)) e-3)) ((equal? e-2 #\\) (if (null? e-3) (REPLC-45Core-n--6145-7373-u--extractString arg-0 arg-1 e-3 (cons e-2 arg-3)) (let ((e-5 (car e-3))) (let ((e-6 (cdr e-3))) (REPLC-45Core-n--6145-7373-u--extractString arg-0 arg-1 e-6 (cons e-5 arg-3))))))(else (REPLC-45Core-n--6145-7373-u--extractString arg-0 arg-1 e-3 (cons e-2 arg-3)))))))))
(define REPLC-45Core-n--6145-7372-u--collectStrings (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-2) (PreludeC-45TypesC-45List-reverse arg-3) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (cond ((equal? e-2 #\]) (PreludeC-45TypesC-45List-reverse arg-3)) ((equal? e-2 #\") (let ((sc2 (REPLC-45Core-n--6145-7373-u--extractString arg-0 arg-1 e-3 '()))) (let ((e-5 (car sc2))) (let ((e-4 (cdr sc2))) (REPLC-45Core-n--6145-7372-u--collectStrings arg-0 arg-1 e-4 (cons e-5 arg-3))))))(else (REPLC-45Core-n--6145-7372-u--collectStrings arg-0 arg-1 e-3 arg-3))))))))
(define REPLC-45Core-n--6145-7376-u--skipWs (lambda (arg-0 arg-1 arg-2) (if (null? arg-2) '() (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (let ((sc1 (let ((sc2 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-2 #\ ))) (cond ((equal? sc2 1) 1) (else (let ((sc3 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-2 (integer->char 10)))) (cond ((equal? sc3 1) 1) (else (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-2 (integer->char 9)))))))))) (cond ((equal? sc1 1) (REPLC-45Core-n--6145-7376-u--skipWs arg-0 arg-1 e-3)) (else (cons e-2 e-3)))))))))
(define REPLC-45Core-n--6145-7375-u--parseArray (lambda (arg-0 arg-1 arg-2) (let ((sc0 (REPLC-45Core-n--6145-7376-u--skipWs arg-0 arg-1 arg-2))) (if (null? sc0) '() (let ((e-1 (car sc0))) (let ((e-2 (cdr sc0))) (cond ((equal? e-1 #\[) (REPLC-45Core-n--6145-7372-u--collectStrings arg-0 arg-1 e-2 '()))(else '()))))))))
(define REPLC-45Core-n--6145-7377-u--startsWith (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-2) 1 (if (null? arg-3) 0 (let ((e-1 (car arg-2))) (let ((e-2 (cdr arg-2))) (let ((e-4 (car arg-3))) (let ((e-5 (cdr arg-3))) (let ((sc4 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-1 e-4))) (cond ((equal? sc4 1) (REPLC-45Core-n--6145-7377-u--startsWith arg-0 arg-1 e-2 e-5)) (else 0)))))))))))
(define REPLC-45Core-n--6145-7374-u--findAndExtractArray (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-3) '() (let ((e-2 (car arg-3))) (let ((e-3 (cdr arg-3))) (let ((sc1 (REPLC-45Core-n--6145-7377-u--startsWith arg-0 arg-1 arg-2 (cons e-2 e-3)))) (cond ((equal? sc1 1) (REPLC-45Core-n--6145-7375-u--parseArray arg-0 arg-1 (DataC-45List-drop (PreludeC-45TypesC-45List-lengthTR arg-2) (cons e-2 e-3)))) (else (REPLC-45Core-n--6145-7374-u--findAndExtractArray arg-0 arg-1 arg-2 e-3)))))))))
(define REPLC-45Core-extractJsonStringArray (lambda (arg-0 arg-1) (let ((u--pattern (string-append "\"" (string-append arg-0 "\":")))) (let ((u--chars (PreludeC-45Types-fastUnpack arg-1))) (REPLC-45Core-n--6145-7374-u--findAndExtractArray arg-1 arg-0 (PreludeC-45Types-fastUnpack u--pattern) u--chars)))))
(define DataC-45Maybe-fromMaybe (lambda (arg-1 arg-2) (if (null? arg-2) (arg-1) (let ((e-2 (unbox arg-2))) e-2))))
(define REPLC-45Core-parseConstraintTypeStr (lambda (arg-0) (let ((sc0 (DataC-45String-isInfixOf "PrimaryKey" arg-0))) (cond ((equal? sc0 1) 0) (else (let ((sc1 (DataC-45String-isInfixOf "ForeignKey" arg-0))) (cond ((equal? sc1 1) 1) (else (let ((sc2 (DataC-45String-isInfixOf "Unique" arg-0))) (cond ((equal? sc2 1) 2) (else (let ((sc3 (DataC-45String-isInfixOf "NotNull" arg-0))) (cond ((equal? sc3 1) 4) (else 3))))))))))))))
(define PreludeC-45Types-u--C-62C-62C-61_Monad_Maybe (lambda (arg-2 arg-3) (if (null? arg-2) '() (let ((e-2 (unbox arg-2))) (arg-3 e-2)))))
(define REPLC-45Core-case--parseConstraintJson-8321 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6) (if (null? arg-6) '() (box arg-6))))
(define REPLC-45Core-parseConstraintJson (lambda (arg-0) (PreludeC-45Types-u--C-62C-62C-61_Monad_Maybe (REPLC-45Core-extractJsonValue "name" arg-0) (lambda (u--name) (let ((u--ctype (DataC-45Maybe-fromMaybe (lambda () "Check") (REPLC-45Core-extractJsonValue "constraint_type" arg-0)))) (PreludeC-45Types-u--C-62C-62C-61_Monad_Maybe (REPLC-45Core-extractJsonValue "table_name" arg-0) (lambda (u--tableName) (let ((u--cols (REPLC-45Core-extractJsonStringArray "columns" arg-0))) (let ((u--foreignTable (REPLC-45Core-extractJsonValue "foreign_table" arg-0))) (let ((u--foreignCols (REPLC-45Core-case--parseConstraintJson-8321 arg-0 u--name u--ctype u--tableName u--cols u--foreignTable (REPLC-45Core-extractJsonStringArray "foreign_columns" arg-0)))) (box (vector u--name (REPLC-45Core-parseConstraintTypeStr u--ctype) u--tableName u--cols u--foreignTable u--foreignCols))))))))))))
(define REPLC-45Core-parseFDJson (lambda (arg-0) (PreludeC-45Types-u--C-62C-62C-61_Monad_Maybe (REPLC-45Core-extractJsonValue "table_name" arg-0) (lambda (u--tableName) (let ((u--det (REPLC-45Core-extractJsonStringArray "determinant" arg-0))) (let ((u--dep (REPLC-45Core-extractJsonStringArray "dependent" arg-0))) (box (vector u--tableName u--det u--dep 1.0))))))))
(define REPLC-45Core-parseDataType (lambda (arg-0) (let ((sc0 (DataC-45String-isInfixOf "int" arg-0))) (cond ((equal? sc0 1) 0) (else (let ((sc1 (DataC-45String-isInfixOf "uuid" arg-0))) (cond ((equal? sc1 1) 4) (else (let ((sc2 (DataC-45String-isInfixOf "bool" arg-0))) (cond ((equal? sc2 1) 2) (else (let ((sc3 (DataC-45String-isInfixOf "timestamp" arg-0))) (cond ((equal? sc3 1) 3) (else (let ((sc4 (DataC-45String-isInfixOf "json" arg-0))) (cond ((equal? sc4 1) 5) (else (let ((sc5 (DataC-45String-isInfixOf "bytea" arg-0))) (cond ((equal? sc5 1) 6) (else 1))))))))))))))))))))
(define REPLC-45Core-parseColumnJson (lambda (arg-0) (PreludeC-45Types-u--C-62C-62C-61_Monad_Maybe (REPLC-45Core-extractJsonValue "name" arg-0) (lambda (u--name) (PreludeC-45Types-u--C-62C-62C-61_Monad_Maybe (REPLC-45Core-extractJsonValue "data_type" arg-0) (lambda (u--dtype) (let ((u--nullable (DataC-45Maybe-fromMaybe (lambda () 0) (REPLC-45Core-extractJsonBool "nullable" arg-0)))) (box (vector u--name (REPLC-45Core-parseDataType u--dtype) u--nullable)))))))))
(define PreludeC-45Types-u--C-62_Ord_Nat (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-1) 2)))
(define REPLC-45Core-n--6599-7799-u--collectObjects (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (if (null? arg-1) (let ((sc1 (PreludeC-45Types-u--null_Foldable_List arg-3))) (cond ((equal? sc1 1) (PreludeC-45TypesC-45List-reverse arg-4)) (else (PreludeC-45TypesC-45List-reverse (cons (PreludeC-45Types-fastPack (PreludeC-45TypesC-45List-reverse arg-3)) arg-4))))) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cond ((equal? e-2 #\]) (cond ((equal? arg-2 0) (let ((sc3 (PreludeC-45Types-u--null_Foldable_List arg-3))) (cond ((equal? sc3 1) (PreludeC-45TypesC-45List-reverse arg-4)) (else (PreludeC-45TypesC-45List-reverse (cons (PreludeC-45Types-fastPack (PreludeC-45TypesC-45List-reverse arg-3)) arg-4))))))(else (let ((sc2 (PreludeC-45Types-u--C-62_Ord_Nat arg-2 0))) (cond ((equal? sc2 1) (REPLC-45Core-n--6599-7799-u--collectObjects arg-0 e-3 arg-2 (cons e-2 arg-3) arg-4)) (else (REPLC-45Core-n--6599-7799-u--collectObjects arg-0 e-3 arg-2 arg-3 arg-4))))))) ((equal? e-2 #\{) (REPLC-45Core-n--6599-7799-u--collectObjects arg-0 e-3 (+ arg-2 1) (cons #\{ arg-3) arg-4)) ((equal? e-2 #\}) (cond ((equal? arg-2 0) (let ((sc3 (PreludeC-45Types-u--C-62_Ord_Nat arg-2 0))) (cond ((equal? sc3 1) (REPLC-45Core-n--6599-7799-u--collectObjects arg-0 e-3 arg-2 (cons e-2 arg-3) arg-4)) (else (REPLC-45Core-n--6599-7799-u--collectObjects arg-0 e-3 arg-2 arg-3 arg-4)))))(else (let ((e-4 (- arg-2 1))) (cond ((equal? e-4 0) (REPLC-45Core-n--6599-7799-u--collectObjects arg-0 e-3 0 '() (cons (PreludeC-45Types-fastPack (PreludeC-45TypesC-45List-reverse (cons #\} arg-3))) arg-4)))(else (REPLC-45Core-n--6599-7799-u--collectObjects arg-0 e-3 e-4 (cons #\} arg-3) arg-4)))))))(else (let ((sc1 (PreludeC-45Types-u--C-62_Ord_Nat arg-2 0))) (cond ((equal? sc1 1) (REPLC-45Core-n--6599-7799-u--collectObjects arg-0 e-3 arg-2 (cons e-2 arg-3) arg-4)) (else (REPLC-45Core-n--6599-7799-u--collectObjects arg-0 e-3 arg-2 arg-3 arg-4)))))))))))
(define REPLC-45Core-n--6599-7800-u--findArrayStart (lambda (arg-0 arg-1) (if (null? arg-1) '() (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cond ((equal? e-2 #\[) (box e-3))(else (REPLC-45Core-n--6599-7800-u--findArrayStart arg-0 e-3))))))))
(define REPLC-45Core-splitJsonArray (lambda (arg-0) (let ((u--chars (PreludeC-45Types-fastUnpack arg-0))) (let ((sc0 (REPLC-45Core-n--6599-7800-u--findArrayStart arg-0 u--chars))) (if (null? sc0) '() (let ((e-2 (unbox sc0))) (REPLC-45Core-n--6599-7799-u--collectObjects arg-0 e-2 0 '() '())))))))
(define REPLC-45Core-n--6889-8073-u--extractUntilClose (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-1) (PreludeC-45TypesC-45List-reverse arg-3) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cond ((equal? e-2 #\[) (REPLC-45Core-n--6889-8073-u--extractUntilClose arg-0 e-3 (+ arg-2 1) (cons #\[ arg-3))) ((equal? e-2 #\]) (cond ((equal? arg-2 0) (PreludeC-45TypesC-45List-reverse arg-3))(else (let ((e-4 (- arg-2 1))) (cond ((equal? e-4 0) (PreludeC-45TypesC-45List-reverse (cons #\] arg-3)))(else (REPLC-45Core-n--6889-8073-u--extractUntilClose arg-0 e-3 e-4 (cons #\] arg-3))))))))(else (REPLC-45Core-n--6889-8073-u--extractUntilClose arg-0 e-3 arg-2 (cons e-2 arg-3)))))))))
(define REPLC-45Core-n--6889-8075-u--startsWith (lambda (arg-0 arg-1 arg-2) (if (null? arg-1) 1 (if (null? arg-2) 0 (let ((e-1 (car arg-1))) (let ((e-2 (cdr arg-1))) (let ((e-4 (car arg-2))) (let ((e-5 (cdr arg-2))) (let ((sc4 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-1 e-4))) (cond ((equal? sc4 1) (REPLC-45Core-n--6889-8075-u--startsWith arg-0 e-2 e-5)) (else 0)))))))))))
(define REPLC-45Core-n--6889-8074-u--findAndExtractSection (lambda (arg-0 arg-1 arg-2) (if (null? arg-2) '() (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (let ((sc1 (REPLC-45Core-n--6889-8075-u--startsWith arg-0 arg-1 (cons e-2 e-3)))) (cond ((equal? sc1 1) (REPLC-45Core-n--6889-8073-u--extractUntilClose arg-0 (DataC-45List-drop (PreludeC-45TypesC-45List-lengthTR arg-1) (cons e-2 e-3)) 0 '())) (else (REPLC-45Core-n--6889-8074-u--findAndExtractSection arg-0 arg-1 e-3)))))))))
(define REPLC-45Core-n--6889-8072-u--extractArraySection (lambda (arg-0 arg-1 arg-2) (let ((u--pattern (string-append "\"" (string-append arg-1 "\":")))) (let ((u--chars (PreludeC-45Types-fastUnpack arg-2))) (PreludeC-45Types-fastPack (REPLC-45Core-n--6889-8074-u--findAndExtractSection arg-0 (PreludeC-45Types-fastUnpack u--pattern) u--chars))))))
(define REPLC-45Core-parseTableJson (lambda (arg-0) (PreludeC-45Types-u--C-62C-62C-61_Monad_Maybe (REPLC-45Core-extractJsonValue "name" arg-0) (lambda (u--name) (let ((u--schemaName (DataC-45Maybe-fromMaybe (lambda () "public") (REPLC-45Core-extractJsonValue "schema_name" arg-0)))) (let ((u--pk (REPLC-45Core-extractJsonStringArray "primary_key" arg-0))) (let ((u--columnsJson (REPLC-45Core-n--6889-8072-u--extractArraySection arg-0 "columns" arg-0))) (let ((u--columns (PreludeC-45TypesC-45List-mapMaybeAppend '() (lambda (eta-0) (REPLC-45Core-parseColumnJson eta-0)) (REPLC-45Core-splitJsonArray u--columnsJson)))) (box (vector u--schemaName u--name u--columns u--pk))))))))))
(define REPLC-45Core-n--7223-8390-u--extractBracket (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-1) (PreludeC-45TypesC-45List-reverse arg-3) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cond ((equal? e-2 #\[) (REPLC-45Core-n--7223-8390-u--extractBracket arg-0 e-3 (+ arg-2 1) (cons #\[ arg-3))) ((equal? e-2 #\]) (cond ((equal? arg-2 0) (PreludeC-45TypesC-45List-reverse arg-3))(else (let ((e-4 (- arg-2 1))) (cond ((equal? e-4 0) (PreludeC-45TypesC-45List-reverse (cons #\] arg-3)))(else (REPLC-45Core-n--7223-8390-u--extractBracket arg-0 e-3 e-4 (cons #\] arg-3))))))))(else (REPLC-45Core-n--7223-8390-u--extractBracket arg-0 e-3 arg-2 (cons e-2 arg-3)))))))))
(define REPLC-45Core-n--7223-8393-u--startsWith (lambda (arg-0 arg-1 arg-2) (if (null? arg-1) 1 (if (null? arg-2) 0 (let ((e-1 (car arg-1))) (let ((e-2 (cdr arg-1))) (let ((e-4 (car arg-2))) (let ((e-5 (cdr arg-2))) (let ((sc4 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-1 e-4))) (cond ((equal? sc4 1) (REPLC-45Core-n--7223-8393-u--startsWith arg-0 e-2 e-5)) (else 0)))))))))))
(define REPLC-45Core-n--7223-8392-u--findSection (lambda (arg-0 arg-1 arg-2) (if (null? arg-2) '() (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (let ((sc1 (REPLC-45Core-n--7223-8393-u--startsWith arg-0 arg-1 (cons e-2 e-3)))) (cond ((equal? sc1 1) (REPLC-45Core-n--7223-8390-u--extractBracket arg-0 (DataC-45List-drop (PreludeC-45TypesC-45List-lengthTR arg-1) (cons e-2 e-3)) 0 '())) (else (REPLC-45Core-n--7223-8392-u--findSection arg-0 arg-1 e-3)))))))))
(define REPLC-45Core-n--7223-8391-u--extractDataSection (lambda (arg-0 arg-1 arg-2) (let ((u--pattern (string-append "\"" (string-append arg-1 "\":")))) (let ((u--chars (PreludeC-45Types-fastUnpack arg-2))) (PreludeC-45Types-fastPack (REPLC-45Core-n--7223-8392-u--findSection arg-0 (PreludeC-45Types-fastUnpack u--pattern) u--chars))))))
(define REPLC-45Core-parseSchemaJson (lambda (arg-0) (PreludeC-45Types-u--C-62C-62C-61_Monad_Maybe (REPLC-45Core-extractJsonBool "success" arg-0) (lambda (_-0) (cond ((equal? _-0 1) (PreludeC-45Types-u--C-62C-62C-61_Monad_Maybe (REPLC-45Core-extractJsonValue "database_name" arg-0) (lambda (u--dbName) (let ((u--tablesSection (REPLC-45Core-n--7223-8391-u--extractDataSection arg-0 "tables" arg-0))) (let ((u--tables (PreludeC-45TypesC-45List-mapMaybeAppend '() (lambda (eta-0) (REPLC-45Core-parseTableJson eta-0)) (REPLC-45Core-splitJsonArray u--tablesSection)))) (let ((u--constraintsSection (REPLC-45Core-n--7223-8391-u--extractDataSection arg-0 "constraints" arg-0))) (let ((u--constraints (PreludeC-45TypesC-45List-mapMaybeAppend '() (lambda (eta-0) (REPLC-45Core-parseConstraintJson eta-0)) (REPLC-45Core-splitJsonArray u--constraintsSection)))) (let ((u--fdsSection (REPLC-45Core-n--7223-8391-u--extractDataSection arg-0 "functional_deps" arg-0))) (let ((u--fds (PreludeC-45TypesC-45List-mapMaybeAppend '() (lambda (eta-0) (REPLC-45Core-parseFDJson eta-0)) (REPLC-45Core-splitJsonArray u--fdsSection)))) (box (vector u--dbName u--tables u--constraints u--fds)))))))))))(else '()))))))
(define PreludeC-45TypesC-45String-length (lambda (arg-0) (PreludeC-45Types-prim__integerToNat (string-length arg-0))))
(define PreludeC-45Types-substr (lambda (arg-0 arg-1 arg-2) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Integer arg-0 (PreludeC-45TypesC-45String-length arg-2)))) (cond ((equal? sc0 1) (string-substr (blodwen-toSignedInt arg-0 63) (blodwen-toSignedInt arg-1 63) arg-2)) (else "")))))
(define REPLC-45Core-sampleSchema (vector "formdb_demo" (cons (vector "public" "authors" (cons (vector "id" 4 0) (cons (vector "name" 1 0) (cons (vector "email" 1 1) (cons (vector "created_at" 3 0) '())))) (cons "id" '())) (cons (vector "public" "articles" (cons (vector "id" 4 0) (cons (vector "title" 1 0) (cons (vector "author_id" 4 0) (cons (vector "content" 1 1) (cons (vector "published_at" 3 1) '()))))) (cons "id" '())) (cons (vector "public" "evidence" (cons (vector "id" 4 0) (cons (vector "article_id" 4 0) (cons (vector "source_url" 1 0) (cons (vector "prompt_score" 0 0) (cons (vector "verified_at" 3 1) '()))))) (cons "id" '())) '()))) (cons (vector "pk_authors" 0 "authors" (cons "id" '()) '() '()) (cons (vector "pk_articles" 0 "articles" (cons "id" '()) '() '()) (cons (vector "fk_articles_author" 1 "articles" (cons "author_id" '()) (box "authors") (box (cons "id" '()))) (cons (vector "pk_evidence" 0 "evidence" (cons "id" '()) '() '()) (cons (vector "fk_evidence_article" 1 "evidence" (cons "article_id" '()) (box "articles") (box (cons "id" '()))) (cons (vector "chk_prompt_score" 3 "evidence" (cons "prompt_score" '()) '() '()) '())))))) (cons (vector "authors" (cons "id" '()) (cons "name" (cons "email" (cons "created_at" '()))) 1.0) (cons (vector "articles" (cons "id" '()) (cons "title" (cons "author_id" (cons "content" (cons "published_at" '())))) 1.0) (cons (vector "evidence" (cons "id" '()) (cons "article_id" (cons "source_url" (cons "prompt_score" (cons "verified_at" '())))) 1.0) (cons (vector "evidence" (cons "article_id" (cons "source_url" '())) (cons "prompt_score" '()) 0.95) '()))))))
(define PreludeC-45Show-u--show_Show_Nat (lambda (arg-0) (PreludeC-45Show-u--show_Show_Integer arg-0)))
(define REPLC-45Core-case--caseC-32blockC-32inC-32caseC-32blockC-32inC-32caseC-32blockC-32inC-32connectToDatabase-9197 (lambda (arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 ext-0) (if (null? arg-6) (let ((act-1 (PreludeC-45IO-prim__putStr "Warning: Failed to parse schema, using demo schema.\xa;" ext-0))) (let ((e-3 (vector-ref arg-1 3))) (let ((e-4 (vector-ref arg-1 4))) (let ((e-5 (vector-ref arg-1 5))) (vector 1 (box arg-0) (box REPLC-45Core-sampleSchema) e-3 e-4 e-5))))) (let ((e-2 (unbox arg-6))) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Schema loaded: " (string-append (PreludeC-45Show-u--show_Show_Nat (PreludeC-45TypesC-45List-lengthTR (let ((e-1 (vector-ref e-2 1))) e-1))) (string-append " tables, " (string-append (PreludeC-45Show-u--show_Show_Nat (PreludeC-45TypesC-45List-lengthTR (let ((e-4 (vector-ref e-2 2))) e-4))) (string-append " constraints, " (string-append (PreludeC-45Show-u--show_Show_Nat (PreludeC-45TypesC-45List-lengthTR (let ((e-3 (vector-ref e-2 3))) e-3))) " FDs")))))) "\xa;") ext-0))) (let ((e-3 (vector-ref arg-1 3))) (let ((e-4 (vector-ref arg-1 4))) (let ((e-5 (vector-ref arg-1 5))) (vector 1 (box arg-0) (box e-2) e-3 e-4 e-5)))))))))
(define REPLC-45Core-connectToDatabase (lambda (arg-0 arg-1 ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Connecting to: " arg-1) "\xa;") ext-0))) (let ((act-2 (REPLC-45Core-execCliCommand (cons "ping" (cons "-c" (cons arg-1 '()))) ext-0))) (case (vector-ref act-2 0) ((0) (let ((e-2 (vector-ref act-2 1))) (let ((act-3 (PreludeC-45IO-prim__putStr (string-append (string-append "Connection failed: " e-2) "\xa;") ext-0))) arg-0))) (else (let ((e-5 (vector-ref act-2 1))) (let ((u--result (vector 1 e-5))) (let ((sc1 (DataC-45String-isInfixOf "connected" e-5))) (cond ((equal? sc1 1) (let ((act-3 (PreludeC-45IO-prim__putStr "Connected. Fetching schema...\xa;" ext-0))) (let ((act-4 (REPLC-45Core-execCliCommand (cons "schema" (cons "-c" (cons arg-1 '()))) ext-0))) (case (vector-ref act-4 0) ((0) (let ((e-2 (vector-ref act-4 1))) (let ((act-5 (PreludeC-45IO-prim__putStr (string-append (string-append "Schema fetch failed: " e-2) "\xa;") ext-0))) (let ((e-7 (vector-ref arg-0 2))) (let ((e-3 (vector-ref arg-0 3))) (let ((e-4 (vector-ref arg-0 4))) (let ((e-6 (vector-ref arg-0 5))) (vector 1 (box arg-1) e-7 e-3 e-4 e-6)))))))) (else (let ((e-6 (vector-ref act-4 1))) (let ((u--schemaResult (vector 1 e-6))) (REPLC-45Core-case--caseC-32blockC-32inC-32caseC-32blockC-32inC-32caseC-32blockC-32inC-32connectToDatabase-9197 arg-1 arg-0 e-5 u--result e-6 u--schemaResult (REPLC-45Core-parseSchemaJson e-6) ext-0)))))))) (else (let ((act-3 (PreludeC-45IO-prim__putStr (string-append (string-append "Connection failed: " (PreludeC-45Types-substr 0 100 e-5)) "\xa;") ext-0))) arg-0))))))))))))
(define DataC-45List-find (lambda (arg-1 arg-2) (if (null? arg-2) '() (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (let ((sc1 (arg-1 e-2))) (cond ((equal? sc1 1) (box e-2)) (else (DataC-45List-find arg-1 e-3)))))))))
(define REPLC-45Core-findTable (lambda (arg-0 arg-1) (DataC-45List-find (lambda (u--t) (PreludeC-45EqOrd-u--C-61C-61_Eq_String (let ((e-1 (vector-ref u--t 1))) e-1) arg-1)) (let ((e-1 (vector-ref arg-0 1))) e-1))))
(define PreludeC-45TypesC-45List-filterAppend (lambda (arg-1 arg-2 arg-3) (if (null? arg-3) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-1 '()) (let ((e-1 (car arg-3))) (let ((e-2 (cdr arg-3))) (let ((sc1 (arg-2 e-1))) (cond ((equal? sc1 1) (PreludeC-45TypesC-45List-filterAppend (cons arg-1 e-1) arg-2 e-2)) (else (PreludeC-45TypesC-45List-filterAppend arg-1 arg-2 e-2)))))))))
(define REPLC-45Core-tableConstraints (lambda (arg-0 arg-1) (PreludeC-45TypesC-45List-filterAppend '() (lambda (u--c) (PreludeC-45EqOrd-u--C-61C-61_Eq_String (let ((e-2 (vector-ref u--c 2))) e-2) arg-1)) (let ((e-2 (vector-ref arg-0 2))) e-2))))
(define REPLC-45Core-tableFDs (lambda (arg-0 arg-1) (PreludeC-45TypesC-45List-filterAppend '() (lambda (u--fd) (PreludeC-45EqOrd-u--C-61C-61_Eq_String (let ((e-0 (vector-ref u--fd 0))) e-0) arg-1)) (let ((e-3 (vector-ref arg-0 3))) e-3))))
(define PreludeC-45Show-n--3216-12633-u--showC-39 (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (if (null? e-3) (string-append arg-3 (let ((e-1 (car arg-1))) (e-1 e-2))) (PreludeC-45Show-n--3216-12633-u--showC-39 arg-1 arg-2 (string-append arg-3 (string-append (let ((e-1 (car arg-1))) (e-1 e-2)) ", ")) e-3)))))))
(define PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 (lambda (arg-1 arg-2) (string-append "[" (string-append (PreludeC-45Show-n--3216-12633-u--showC-39 arg-1 arg-2 "" arg-2) "]"))))
(define REPLC-45Core-u--show_Show_DataType (lambda (arg-0) (cond ((equal? arg-0 0) "integer") ((equal? arg-0 1) "text") ((equal? arg-0 2) "boolean") ((equal? arg-0 3) "timestamp") ((equal? arg-0 4) "uuid") ((equal? arg-0 5) "jsonb") (else "bytea"))))
(define REPLC-45Core-u--show_Show_Column (lambda (arg-0) (string-append (let ((e-0 (vector-ref arg-0 0))) e-0) (string-append " " (string-append (REPLC-45Core-u--show_Show_DataType (let ((e-1 (vector-ref arg-0 1))) e-1)) (let ((sc0 (let ((e-2 (vector-ref arg-0 2))) e-2))) (cond ((equal? sc0 1) " NULL") (else " NOT NULL"))))))))
(define REPLC-45Core-case--caseC-32blockC-32inC-32describeTable-9952 (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (if (null? arg-3) (PreludeC-45IO-prim__putStr (string-append (string-append "Table not found: " arg-0) "\xa;") ext-0) (let ((e-2 (unbox arg-3))) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "\xa;Table: " (string-append (let ((e-0 (vector-ref e-2 0))) e-0) (string-append "." (let ((e-1 (vector-ref e-2 1))) e-1)))) "\xa;") ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "\xa;Columns:\xa;" ext-0))) (let ((act-3 (((PreludeC-45Interfaces-traverse_ (force csegen-13) (force csegen-28) (lambda (u--c) (lambda (eta-0) (PreludeC-45IO-prim__putStr (string-append (string-append "  " (REPLC-45Core-u--show_Show_Column u--c)) "\xa;") eta-0)))) (let ((e-4 (vector-ref e-2 2))) e-4)) ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr "\xa;Primary Key:\xa;" ext-0))) (let ((act-5 (PreludeC-45IO-prim__putStr (string-append (string-append "  " (PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 (force csegen-1) (let ((e-3 (vector-ref e-2 3))) e-3))) "\xa;") ext-0))) (let ((act-6 (PreludeC-45IO-prim__putStr "\xa;Constraints:\xa;" ext-0))) (((let ((u--cons (REPLC-45Core-tableConstraints arg-2 arg-0))) (lambda () (lambda (world-0) (let ((act-7 (let ((sc1 (PreludeC-45Types-u--null_Foldable_List u--cons))) (cond ((equal? sc1 1) (PreludeC-45IO-prim__putStr "  (none)\xa;" world-0)) (else (((force csegen-30) u--cons) world-0)))))) (let ((act-8 (PreludeC-45IO-prim__putStr "\xa;Functional Dependencies:\xa;" world-0))) (((let ((u--fds (REPLC-45Core-tableFDs arg-2 arg-0))) (let ((sc1 (PreludeC-45Types-u--null_Foldable_List u--fds))) (cond ((equal? sc1 1) (lambda () (force csegen-6))) (else (lambda () ((force csegen-33) u--fds))))))) world-0))))))) ext-0)))))))))))
(define REPLC-45Core-case--describeTable-9926 (lambda (arg-0 arg-1 arg-2) (lambda (clam-0) (if (null? arg-2) (PreludeC-45IO-prim__putStr "No schema loaded.\xa;" clam-0) (let ((e-2 (unbox arg-2))) (REPLC-45Core-case--caseC-32blockC-32inC-32describeTable-9952 arg-0 arg-1 e-2 (REPLC-45Core-findTable e-2 arg-0) clam-0))))))
(define REPLC-45Core-describeTable (lambda (arg-0 arg-1) (REPLC-45Core-case--describeTable-9926 arg-1 arg-0 (let ((e-2 (vector-ref arg-0 2))) e-2))))
(define REPLC-45Core-disconnectFromDatabase (lambda (arg-0 ext-0) (let ((sc0 (let ((e-0 (vector-ref arg-0 0))) e-0))) (cond ((equal? sc0 0) (let ((act-1 (PreludeC-45IO-prim__putStr "Not connected.\xa;" ext-0))) arg-0)) (else (let ((act-1 (PreludeC-45IO-prim__putStr "Disconnected.\xa;" ext-0))) (let ((e-3 (vector-ref arg-0 3))) (let ((e-4 (vector-ref arg-0 4))) (let ((e-5 (vector-ref arg-0 5))) (vector 0 '() '() e-3 e-4 e-5))))))))))
(define REPLC-45Core-case--caseC-32blockC-32inC-32explainConstraint-10606 (lambda (arg-0 arg-1 arg-2 arg-3 ext-0) (if (null? arg-3) (PreludeC-45IO-prim__putStr (string-append (string-append "Constraint not found: " arg-0) "\xa;") ext-0) (let ((e-2 (unbox arg-3))) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "\xa;Constraint: " (let ((e-0 (vector-ref e-2 0))) e-0)) "\xa;") ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr (string-append (string-append "Type: " (REPLC-45Core-u--show_Show_ConstraintType (let ((e-1 (vector-ref e-2 1))) e-1))) "\xa;") ext-0))) (let ((act-3 (PreludeC-45IO-prim__putStr (string-append (string-append "Table: " (let ((e-6 (vector-ref e-2 2))) e-6)) "\xa;") ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr (string-append (string-append "Columns: " (PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 (force csegen-1) (let ((e-3 (vector-ref e-2 3))) e-3))) "\xa;") ext-0))) (((let ((sc1 (let ((e-1 (vector-ref e-2 1))) e-1))) (cond ((equal? sc1 1) (lambda () (lambda (world-0) (let ((act-5 (PreludeC-45IO-prim__putStr (string-append (string-append "References: " (DataC-45Maybe-fromMaybe (lambda () "?") (let ((e-4 (vector-ref e-2 4))) e-4))) "\xa;") world-0))) (let ((act-6 (PreludeC-45IO-prim__putStr (string-append (string-append "Foreign Columns: " (PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 (force csegen-1) (DataC-45Maybe-fromMaybe (lambda () '()) (let ((e-5 (vector-ref e-2 5))) e-5)))) "\xa;") world-0))) (let ((act-7 (PreludeC-45IO-prim__putStr "\xa;" world-0))) (let ((act-8 (PreludeC-45IO-prim__putStr "This constraint ensures referential integrity.\xa;" world-0))) (PreludeC-45IO-prim__putStr "Violations occur when referenced rows are missing.\xa;" world-0)))))))) ((equal? sc1 0) (lambda () (lambda (world-0) (let ((act-5 (PreludeC-45IO-prim__putStr "\xa;" world-0))) (let ((act-6 (PreludeC-45IO-prim__putStr "This constraint ensures row uniqueness.\xa;" world-0))) (PreludeC-45IO-prim__putStr "Violations occur with duplicate key values.\xa;" world-0)))))) ((equal? sc1 2) (lambda () (lambda (world-0) (let ((act-5 (PreludeC-45IO-prim__putStr "\xa;" world-0))) (let ((act-6 (PreludeC-45IO-prim__putStr "This constraint ensures column uniqueness.\xa;" world-0))) (PreludeC-45IO-prim__putStr "Violations occur with duplicate values.\xa;" world-0)))))) ((equal? sc1 3) (lambda () (lambda (world-0) (let ((act-5 (PreludeC-45IO-prim__putStr "\xa;" world-0))) (let ((act-6 (PreludeC-45IO-prim__putStr "This constraint validates data values.\xa;" world-0))) (PreludeC-45IO-prim__putStr "Violations occur when check expression is false.\xa;" world-0)))))) (else (lambda () (lambda (world-0) (let ((act-5 (PreludeC-45IO-prim__putStr "\xa;" world-0))) (PreludeC-45IO-prim__putStr "This constraint prevents NULL values.\xa;" world-0)))))))) ext-0)))))))))
(define REPLC-45Core-case--explainConstraint-10573 (lambda (arg-0 arg-1 arg-2) (lambda (clam-0) (if (null? arg-2) (PreludeC-45IO-prim__putStr "No schema loaded.\xa;" clam-0) (let ((e-2 (unbox arg-2))) (REPLC-45Core-case--caseC-32blockC-32inC-32explainConstraint-10606 arg-0 arg-1 e-2 (DataC-45List-find (lambda (u--c) (PreludeC-45EqOrd-u--C-61C-61_Eq_String (let ((e-0 (vector-ref u--c 0))) e-0) arg-0)) (let ((e-4 (vector-ref e-2 2))) e-4)) clam-0))))))
(define REPLC-45Core-explainConstraint (lambda (arg-0 arg-1) (REPLC-45Core-case--explainConstraint-10573 arg-1 arg-0 (let ((e-2 (vector-ref arg-0 2))) e-2))))
(define REPLC-45Core-u--show_Show_Table (lambda (arg-0) (string-append (let ((e-0 (vector-ref arg-0 0))) e-0) (string-append "." (string-append (let ((e-1 (vector-ref arg-0 1))) e-1) (string-append " (" (string-append (PreludeC-45Show-u--show_Show_Nat (PreludeC-45TypesC-45List-lengthTR (let ((e-2 (vector-ref arg-0 2))) e-2))) " columns)")))))))
(define REPLC-45Core-listTables (lambda (arg-0 ext-0) (let ((e-2 (vector-ref arg-0 2))) (if (null? e-2) (PreludeC-45IO-prim__putStr "No schema loaded.\xa;" ext-0) (let ((e-6 (unbox e-2))) (let ((act-1 (PreludeC-45IO-prim__putStr "Tables:\xa;" ext-0))) (((PreludeC-45Interfaces-traverse_ (force csegen-13) (force csegen-28) (lambda (u--t) (lambda (eta-0) (PreludeC-45IO-prim__putStr (string-append (string-append "  " (REPLC-45Core-u--show_Show_Table u--t)) "\xa;") eta-0)))) (let ((e-9 (vector-ref e-6 1))) e-9)) ext-0)))))))
(define REPLC-45Core-loadDemo (lambda (arg-0 ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "Loading demo schema: formdb_demo\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "  3 tables, 6 constraints, 4 functional dependencies\xa;" ext-0))) (let ((e-0 (vector-ref arg-0 0))) (let ((e-1 (vector-ref arg-0 1))) (let ((e-3 (vector-ref arg-0 3))) (let ((e-4 (vector-ref arg-0 4))) (let ((e-5 (vector-ref arg-0 5))) (vector e-0 e-1 (box REPLC-45Core-sampleSchema) e-3 e-4 e-5))))))))))
(define REPLC-45Core-runDiagnose (lambda (arg-0 ext-0) (let ((e-2 (vector-ref arg-0 2))) (if (null? e-2) (PreludeC-45IO-prim__putStr "No schema loaded.\xa;" ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "Running constraint diagnostics...\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "\xa;" ext-0))) (let ((act-3 (PreludeC-45IO-prim__putStr "  Checking primary keys... OK\xa;" ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr "  Checking foreign keys... OK\xa;" ext-0))) (let ((act-5 (PreludeC-45IO-prim__putStr "  Checking unique constraints... OK\xa;" ext-0))) (let ((act-6 (PreludeC-45IO-prim__putStr "  Checking functional dependencies... OK\xa;" ext-0))) (let ((act-7 (PreludeC-45IO-prim__putStr "\xa;" ext-0))) (let ((act-8 (PreludeC-45IO-prim__putStr "No violations found.\xa;" ext-0))) (let ((act-9 (PreludeC-45IO-prim__putStr "\xa;" ext-0))) (PreludeC-45IO-prim__putStr "Note: Full diagnostics require database connection.\xa;" ext-0))))))))))))))
(define REPLC-45Core-case--showAllConstraints-10376 (lambda (arg-0 arg-1 ext-0) (if (null? arg-1) (PreludeC-45IO-prim__putStr "No schema loaded.\xa;" ext-0) (let ((e-2 (unbox arg-1))) (let ((act-1 (PreludeC-45IO-prim__putStr "Constraints:\xa;" ext-0))) (((let ((sc1 (PreludeC-45Types-u--null_Foldable_List (let ((e-4 (vector-ref e-2 2))) e-4)))) (cond ((equal? sc1 1) (lambda () (force csegen-6))) (else (lambda () ((force csegen-30) (let ((e-4 (vector-ref e-2 2))) e-4))))))) ext-0))))))
(define REPLC-45Core-showAllConstraints (lambda (arg-0 ext-0) (REPLC-45Core-case--showAllConstraints-10376 arg-0 (let ((e-2 (vector-ref arg-0 2))) e-2) ext-0)))
(define REPLC-45Core-case--showAllFDs-10195 (lambda (arg-0 arg-1 ext-0) (if (null? arg-1) (PreludeC-45IO-prim__putStr "No schema loaded.\xa;" ext-0) (let ((e-2 (unbox arg-1))) (let ((act-1 (PreludeC-45IO-prim__putStr "Functional Dependencies:\xa;" ext-0))) (((let ((sc1 (PreludeC-45Types-u--null_Foldable_List (let ((e-3 (vector-ref e-2 3))) e-3)))) (cond ((equal? sc1 1) (lambda () (force csegen-6))) (else (lambda () ((force csegen-33) (let ((e-3 (vector-ref e-2 3))) e-3))))))) ext-0))))))
(define REPLC-45Core-showAllFDs (lambda (arg-0 ext-0) (REPLC-45Core-case--showAllFDs-10195 arg-0 (let ((e-2 (vector-ref arg-0 2))) e-2) ext-0)))
(define REPLC-45Core-showHelp (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "FormDB Debugger Commands\xa;" ext-0))) (let ((act-3 (PreludeC-45IO-prim__putStr "========================\xa;" ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr "\xa;" ext-0))) (let ((act-5 (PreludeC-45IO-prim__putStr "Connection:\xa;" ext-0))) (let ((act-6 (PreludeC-45IO-prim__putStr "  connect <uri>     Connect to PostgreSQL database\xa;" ext-0))) (let ((act-7 (PreludeC-45IO-prim__putStr "  disconnect        Disconnect from database\xa;" ext-0))) (let ((act-8 (PreludeC-45IO-prim__putStr "  status            Show connection status\xa;" ext-0))) (let ((act-9 (PreludeC-45IO-prim__putStr "  demo              Load demo schema for exploration\xa;" ext-0))) (let ((act-10 (PreludeC-45IO-prim__putStr "\xa;" ext-0))) (let ((act-11 (PreludeC-45IO-prim__putStr "Schema Inspection:\xa;" ext-0))) (let ((act-12 (PreludeC-45IO-prim__putStr "  schema            Show loaded schema summary\xa;" ext-0))) (let ((act-13 (PreludeC-45IO-prim__putStr "  tables            List all tables\xa;" ext-0))) (let ((act-14 (PreludeC-45IO-prim__putStr "  describe <table>  Show table structure\xa;" ext-0))) (let ((act-15 (PreludeC-45IO-prim__putStr "\xa;" ext-0))) (let ((act-16 (PreludeC-45IO-prim__putStr "Constraints & FDs:\xa;" ext-0))) (let ((act-17 (PreludeC-45IO-prim__putStr "  fds               Show all functional dependencies\xa;" ext-0))) (let ((act-18 (PreludeC-45IO-prim__putStr "  fds <table>       Show FDs for specific table\xa;" ext-0))) (let ((act-19 (PreludeC-45IO-prim__putStr "  constraints       Show all constraints\xa;" ext-0))) (let ((act-20 (PreludeC-45IO-prim__putStr "\xa;" ext-0))) (let ((act-21 (PreludeC-45IO-prim__putStr "Diagnostics:\xa;" ext-0))) (let ((act-22 (PreludeC-45IO-prim__putStr "  diagnose          Check for constraint violations\xa;" ext-0))) (let ((act-23 (PreludeC-45IO-prim__putStr "  explain <name>    Explain a constraint\xa;" ext-0))) (let ((act-24 (PreludeC-45IO-prim__putStr "\xa;" ext-0))) (let ((act-25 (PreludeC-45IO-prim__putStr "General:\xa;" ext-0))) (let ((act-26 (PreludeC-45IO-prim__putStr "  help              Show this help\xa;" ext-0))) (let ((act-27 (PreludeC-45IO-prim__putStr "  quit              Exit debugger\xa;" ext-0))) (PreludeC-45IO-prim__putStr "\xa;" ext-0))))))))))))))))))))))))))))))
(define REPLC-45Core-case--showSchemaInfo-9797 (lambda (arg-0 arg-1 ext-0) (if (null? arg-1) (PreludeC-45IO-prim__putStr "No schema loaded. Use 'demo' to load sample schema.\xa;" ext-0) (let ((e-2 (unbox arg-1))) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Database: " (let ((e-0 (vector-ref e-2 0))) e-0)) "\xa;") ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr (string-append (string-append "Tables: " (PreludeC-45Show-u--show_Show_Nat (PreludeC-45TypesC-45List-lengthTR (let ((e-1 (vector-ref e-2 1))) e-1)))) "\xa;") ext-0))) (let ((act-3 (PreludeC-45IO-prim__putStr (string-append (string-append "Constraints: " (PreludeC-45Show-u--show_Show_Nat (PreludeC-45TypesC-45List-lengthTR (let ((e-4 (vector-ref e-2 2))) e-4)))) "\xa;") ext-0))) (PreludeC-45IO-prim__putStr (string-append (string-append "Functional Dependencies: " (PreludeC-45Show-u--show_Show_Nat (PreludeC-45TypesC-45List-lengthTR (let ((e-3 (vector-ref e-2 3))) e-3)))) "\xa;") ext-0))))))))
(define REPLC-45Core-showSchemaInfo (lambda (arg-0 ext-0) (REPLC-45Core-case--showSchemaInfo-9797 arg-0 (let ((e-2 (vector-ref arg-0 2))) e-2) ext-0)))
(define PreludeC-45Show-u--show_Show_Bool (lambda (arg-0) (cond ((equal? arg-0 1) "True") (else "False"))))
(define REPLC-45Core-showStatus (lambda (arg-0 ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Connected: " (PreludeC-45Show-u--show_Show_Bool (let ((e-0 (vector-ref arg-0 0))) e-0))) "\xa;") ext-0))) (let ((act-2 (let ((e-1 (vector-ref arg-0 1))) (if (null? e-1) (PreludeC-45IO-prim__putStr "No connection URI\xa;" ext-0) (let ((e-6 (unbox e-1))) (PreludeC-45IO-prim__putStr (string-append (string-append "URI: " e-6) "\xa;") ext-0)))))) (((let ((e-2 (vector-ref arg-0 2))) (if (null? e-2) (lambda () (lambda (eta-0) (PreludeC-45IO-prim__putStr "No schema loaded\xa;" eta-0))) (let ((e-6 (unbox e-2))) (lambda () (lambda (eta-0) (PreludeC-45IO-prim__putStr (string-append (string-append "Schema: " (let ((e-10 (vector-ref e-6 0))) e-10)) "\xa;") eta-0))))))) ext-0)))))
(define REPLC-45Core-case--showTableFDs-10278 (lambda (arg-0 arg-1 arg-2) (if (null? arg-2) (lambda (eta-0) (PreludeC-45IO-prim__putStr "No schema loaded.\xa;" eta-0)) (let ((e-2 (unbox arg-2))) (let ((u--fds (REPLC-45Core-tableFDs e-2 arg-0))) (lambda (world-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Functional Dependencies for " (string-append arg-0 ":")) "\xa;") world-0))) (((let ((sc1 (PreludeC-45Types-u--null_Foldable_List u--fds))) (cond ((equal? sc1 1) (lambda () (force csegen-6))) (else (lambda () ((force csegen-33) u--fds)))))) world-0))))))))
(define REPLC-45Core-showTableFDs (lambda (arg-0 arg-1) (REPLC-45Core-case--showTableFDs-10278 arg-1 arg-0 (let ((e-2 (vector-ref arg-0 2))) e-2))))
(define PreludeC-45TypesC-45List-mapAppend (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-2 '()) (let ((e-1 (car arg-4))) (let ((e-2 (cdr arg-4))) (PreludeC-45TypesC-45List-mapAppend (cons arg-2 (arg-3 e-1)) arg-3 e-2))))))
(define DataC-45String-n--3884-9463-u--wordsHelper (lambda (arg-0 arg-1 arg-2) (if (null? arg-1) arg-2 (cons arg-2 (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-1 '())))))
(define DataC-45String-n--3884-9462-u--wordsC-39 (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-1) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 (DataC-45String-n--3884-9463-u--wordsHelper arg-0 arg-2 arg-3) '()) (let ((e-1 (car arg-1))) (let ((e-2 (cdr arg-1))) (let ((sc1 (PreludeC-45Types-isSpace e-1))) (cond ((equal? sc1 1) (DataC-45String-n--3884-9462-u--wordsC-39 arg-0 e-2 '() (DataC-45String-n--3884-9463-u--wordsHelper arg-0 arg-2 arg-3))) (else (DataC-45String-n--3884-9462-u--wordsC-39 arg-0 e-2 (cons arg-2 e-1) arg-3)))))))))
(define DataC-45String-words (lambda (arg-0) (PreludeC-45TypesC-45List-mapAppend '() (lambda (eta-0) (PreludeC-45Types-fastPack eta-0)) (DataC-45String-n--3884-9462-u--wordsC-39 arg-0 (PreludeC-45Types-fastUnpack arg-0) '() '()))))
(define REPLC-45Core-processCommand (lambda (arg-0 arg-1) (let ((u--parts (DataC-45String-words arg-1))) (if (null? u--parts) (lambda (world-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") world-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" world-0))) arg-0))) (let ((e-1 (car u--parts))) (let ((e-2 (cdr u--parts))) (cond ((equal? e-1 "help") (lambda (clam-0) (if (null? e-2) (let ((act-1 (REPLC-45Core-showHelp clam-0))) arg-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") clam-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" clam-0))) arg-0))))) ((equal? e-1 "demo") (lambda (clam-0) (if (null? e-2) (REPLC-45Core-loadDemo arg-0 clam-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") clam-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" clam-0))) arg-0))))) ((equal? e-1 "connect") (lambda (clam-1) (if (null? e-2) (let ((act-1 (PreludeC-45IO-prim__putStr "Usage: connect <connection_string>\xa;" clam-1))) (let ((act-2 (PreludeC-45IO-prim__putStr "Example: connect postgres://user:pass@localhost/mydb\xa;" clam-1))) arg-0)) (REPLC-45Core-connectToDatabase arg-0 (DataC-45String-unwords e-2) clam-1)))) ((equal? e-1 "disconnect") (lambda (clam-0) (if (null? e-2) (REPLC-45Core-disconnectFromDatabase arg-0 clam-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") clam-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" clam-0))) arg-0))))) ((equal? e-1 "status") (lambda (clam-1) (if (null? e-2) (let ((act-1 (REPLC-45Core-showStatus arg-0 clam-1))) arg-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") clam-1))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" clam-1))) arg-0))))) ((equal? e-1 "schema") (lambda (clam-2) (if (null? e-2) (let ((act-1 (REPLC-45Core-showSchemaInfo arg-0 clam-2))) arg-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") clam-2))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" clam-2))) arg-0))))) ((equal? e-1 "tables") (lambda (clam-3) (if (null? e-2) (let ((act-1 (REPLC-45Core-listTables arg-0 clam-3))) arg-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") clam-3))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" clam-3))) arg-0))))) ((equal? e-1 "describe") (lambda (clam-2) (if (null? e-2) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") clam-2))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" clam-2))) arg-0)) (let ((e-10 (car e-2))) (let ((e-11 (cdr e-2))) (if (null? e-11) (let ((act-1 ((REPLC-45Core-describeTable arg-0 e-10) clam-2))) arg-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") clam-2))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" clam-2))) arg-0)))))))) ((equal? e-1 "fds") (lambda (clam-3) (if (null? e-2) (let ((act-1 (REPLC-45Core-showAllFDs arg-0 clam-3))) arg-0) (let ((e-15 (car e-2))) (let ((e-16 (cdr e-2))) (if (null? e-16) (let ((act-1 ((REPLC-45Core-showTableFDs arg-0 e-15) clam-3))) arg-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") clam-3))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" clam-3))) arg-0)))))))) ((equal? e-1 "constraints") (lambda (clam-6) (if (null? e-2) (let ((act-1 (REPLC-45Core-showAllConstraints arg-0 clam-6))) arg-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") clam-6))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" clam-6))) arg-0))))) ((equal? e-1 "diagnose") (lambda (clam-7) (if (null? e-2) (let ((act-1 (REPLC-45Core-runDiagnose arg-0 clam-7))) arg-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") clam-7))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" clam-7))) arg-0))))) ((equal? e-1 "explain") (lambda (clam-4) (if (null? e-2) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") clam-4))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" clam-4))) arg-0)) (let ((e-21 (car e-2))) (let ((e-22 (cdr e-2))) (if (null? e-22) (let ((act-1 ((REPLC-45Core-explainConstraint arg-0 e-21) clam-4))) arg-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") clam-4))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" clam-4))) arg-0))))))))(else (lambda (world-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Unknown command: " arg-1) "\xa;") world-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands.\xa;" world-0))) arg-0)))))))))))
(define REPLC-45Core-case--runREPL-11205 (lambda (arg-0 arg-1 arg-2 ext-0) (cond ((equal? arg-2 "quit") (PreludeC-45IO-prim__putStr "Goodbye!\xa;" ext-0)) ((equal? arg-2 "exit") (PreludeC-45IO-prim__putStr "Goodbye!\xa;" ext-0)) ((equal? arg-2 "") (REPLC-45Core-runREPL arg-0 ext-0))(else (let ((act-1 ((REPLC-45Core-processCommand arg-0 arg-2) ext-0))) (REPLC-45Core-runREPL act-1 ext-0))))))
(define REPLC-45Core-runREPL (lambda (arg-0 ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "formdb-debug> " ext-0))) (let ((act-2 (PreludeC-45IO-prim__getStr ext-0))) (REPLC-45Core-case--runREPL-11205 arg-0 act-2 (DataC-45String-trim act-2) ext-0)))))
(define Main-main (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "FormDB Debugger v0.1.0\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "Type 'help' for available commands, 'quit' to exit.\xa;" ext-0))) (let ((act-3 (PreludeC-45IO-prim__putStr "\xa;" ext-0))) (REPLC-45Core-runREPL REPLC-45Core-initialState ext-0))))))
(define PreludeC-45EqOrd-compareInteger (lambda (ext-0 ext-1) (PreludeC-45EqOrd-u--compare_Ord_Integer ext-0 ext-1)))
(collect-request-handler
  (let* ([gc-counter 1]
         [log-radix 2]
         [radix-mask (sub1 (bitwise-arithmetic-shift 1 log-radix))]
         [major-gc-factor 2]
         [trigger-major-gc-allocated (* major-gc-factor (bytes-allocated))])
    (lambda ()
      (cond
        [(>= (bytes-allocated) trigger-major-gc-allocated)
         ;; Force a major collection if memory use has doubled
         (collect (collect-maximum-generation))
         (blodwen-run-finalisers)
         (set! trigger-major-gc-allocated (* major-gc-factor (bytes-allocated)))]
        [else
         ;; Imitate the built-in rule, but without ever going to a major collection
         (let ([this-counter gc-counter])
           (if (> (add1 this-counter)
                  (bitwise-arithmetic-shift-left 1 (* log-radix (sub1 (collect-maximum-generation)))))
               (set! gc-counter 1)
               (set! gc-counter (add1 this-counter)))
           (collect
            ;; Find the minor generation implied by the counter
            (let loop ([c this-counter] [gen 0])
              (cond
                [(zero? (bitwise-and c radix-mask))
                 (loop (bitwise-arithmetic-shift-right c log-radix)
                       (add1 gen))]
                [else
                 gen]))))]))))
(PrimIO-unsafePerformIO (lambda (eta-0) (Main-main eta-0)))
  (collect-request-handler (lambda () (collect (collect-maximum-generation)) (blodwen-run-finalisers)))
  (collect-rendezvous)
  
  )