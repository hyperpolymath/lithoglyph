= FormDB Roadmap
:toc:
:icons: font

[.lead]
Development phases from concept to production.

== Phase 0: Specification (Current)

*Goal*: Complete specifications for all core components.

=== Deliverables

* [x] `formdb.scm` - Unified specification
* [x] Repository structure
* [ ] `spec/blocks.adoc` - Block format spec
* [ ] `spec/journal.adoc` - Journal format spec
* [ ] `spec/rendering.adoc` - Canonical rendering rules
* [ ] `spec/fql.adoc` - FQL grammar

=== Open Questions to Resolve

* Q-BLOCK-HEADER-001: Block header layout
* Q-JOURNAL-ENTRY-001: Journal entry schema
* Q-ABI-BLOBS-001: ABI blob encoding
* Q-FQL-POC-001: FQL grammar

== Phase 1: Form.Blocks PoC

*Goal*: Working storage layer with journal and reversibility.

=== Deliverables

* [ ] Fixed-size block implementation
* [ ] Append-only journal
* [ ] Crash recovery
* [ ] Integrity checks
* [ ] Repair guidance
* [ ] Golden test vectors

=== Acceptance Criteria

* All block operations journaled
* Crash recovery restores consistent state
* Deterministic text rendering for all blocks
* Test vectors pass

== Phase 2: Form.Model PoC

*Goal*: Multi-model layer on top of blocks.

=== Deliverables

* [ ] Document collections
* [ ] Edge collections
* [ ] Schema metadata storage
* [ ] Constraint enforcement
* [ ] Migration artefacts

=== Acceptance Criteria

* Documents insertable/queryable
* Edges create graph relationships
* Constraints produce explainable rejections
* Migrations are reversible

== Phase 3: Form.Bridge

*Goal*: Stable C ABI for runtime integration.

=== Deliverables

* [ ] Zig ABI implementation
* [ ] Error blob handling
* [ ] Introspection surfaces
* [ ] Render surfaces

=== Acceptance Criteria

* FFI callable from Factor
* All errors are renderable
* Introspection returns usable data
* No memory leaks across boundary

== Phase 4: Form.Runtime PoC

*Goal*: FQL parser/planner/executor.

=== Deliverables

* [ ] FQL parser
* [ ] Query planner
* [ ] Executor
* [ ] EXPLAIN functionality
* [ ] Provenance output

=== Acceptance Criteria

* FQL PoC subset fully functional
* EXPLAIN returns readable plans
* Provenance tracks to journal entries
* Constraint rejections explained

== Phase 5: Integration & Polish

*Goal*: Complete PoC with all seam checks passing.

=== Deliverables

* [ ] Seam check automation
* [ ] End-to-end test suite
* [ ] Documentation polish
* [ ] Example narratives

=== Acceptance Criteria

* All seam checks (B↔M, M↔R, B↔R) pass
* Golden test vectors complete
* Stories demonstrate target use cases

== Phase 6: Form.Normalizer (Self-Normalizing)

*Goal*: Automatic functional dependency discovery, type-encoded normal forms, and proof-carrying schema evolution.

=== Deliverables

* [ ] FD discovery algorithm (DFD/TANE/FDHits)
* [ ] `DISCOVER DEPENDENCIES` FQL command
* [ ] Type encoding in Lean 4 (FQL-dt integration)
* [ ] Normal form predicates (1NF through BCNF)
* [ ] Proposal generation with equivalence proofs
* [ ] Narrative templates for all normalization decisions
* [ ] `APPLY NORMALIZATION` command with rollback

=== Acceptance Criteria

* Discover FDs from sample data with configurable confidence threshold
* Encode discovered FDs as dependent types in FQL-dt
* Prove schema satisfies target normal form (1NF-BCNF)
* Generate human/agent-readable proposals
* Apply transformations with journaled reversibility
* All normalization decisions produce narrative artefacts

=== Open Questions

* Q-NORM-001: Default FD discovery algorithm
* Q-NORM-002: Approximate FD handling policy
* Q-NORM-003: Denormalization support scope
* Q-NORM-004: FQL-dt proof integration interface
* Q-NORM-005: Query rewriting for affected queries

See link:spec/self-normalizing.adoc[Self-Normalizing Specification] for full details.

== Future Phases (Post-PoC)

=== Form.ControlPlane

* Elixir/OTP session management
* Cluster coordination
* Production supervision

=== Distribution

* Multi-node replication
* Consensus protocol selection
* Network protocol design

=== Ecosystem

* Language bindings (Rust, Python, etc.)
* IDE integration
* Visualization tools

== Non-Goals (Explicitly Deferred)

* SQL compatibility layer
* OLAP optimizations
* Full-text search
* Time-series optimizations
* Real-time subscriptions

These may be addressed post-PoC based on community needs.
