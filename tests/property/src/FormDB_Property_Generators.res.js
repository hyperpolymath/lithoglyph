// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";
import * as FormDB_Property_Types from "./FormDB_Property_Types.res.js";

function makeRng(seed) {
  return {
          seed: seed
        };
}

function nextInt(rng) {
  rng.seed = Math.imul(rng.seed, 1103515245) + 12345 & 2147483647;
  return rng.seed;
}

function intInRange(rng, min, max) {
  var range = max - min | 0;
  if (range <= 0) {
    return min;
  } else {
    return min + Caml_int32.mod_(PervasivesU.abs(nextInt(rng)), range) | 0;
  }
}

function float01(rng) {
  return PervasivesU.abs(nextInt(rng)) / 2147483648.0;
}

function bool(rng) {
  return nextInt(rng) % 2 === 0;
}

function pick(rng, arr) {
  var len = arr.length;
  if (len === 0) {
    return ;
  } else {
    return Caml_option.some(Core__Option.getExn(arr[intInRange(rng, 0, len)], undefined));
  }
}

function identifier(rng) {
  var prefixes = [
    "user",
    "post",
    "article",
    "product",
    "order",
    "item",
    "comment",
    "tag",
    "category"
  ];
  var suffixes = [
    "",
    "s",
    "_data",
    "_info",
    "_record"
  ];
  var prefix = Core__Option.getOr(pick(rng, prefixes), "item");
  var suffix = Core__Option.getOr(pick(rng, suffixes), "");
  return prefix + suffix;
}

function fieldName(rng) {
  var fields = [
    "id",
    "name",
    "title",
    "description",
    "content",
    "status",
    "created_at",
    "updated_at",
    "author",
    "email",
    "price",
    "quantity",
    "active",
    "published",
    "category_id",
    "user_id"
  ];
  return Core__Option.getOr(pick(rng, fields), "field");
}

function stringValue(rng) {
  var words = [
    "hello",
    "world",
    "test",
    "example",
    "sample",
    "data",
    "value"
  ];
  var len = intInRange(rng, 1, 4);
  var result = [];
  for(var _for = 1; _for <= len; ++_for){
    result.push(Core__Option.getOr(pick(rng, words), "word"));
  }
  return result.join(" ");
}

function valueType(rng) {
  var choice = intInRange(rng, 0, 5);
  switch (choice) {
    case 1 :
        return {
                TAG: "IntVal",
                _0: intInRange(rng, -1000, 1000)
              };
    case 2 :
        return {
                TAG: "FloatVal",
                _0: float01(rng) * 1000.0
              };
    case 3 :
        return {
                TAG: "BoolVal",
                _0: bool(rng)
              };
    case 4 :
        return "NullVal";
    default:
      return {
              TAG: "StringVal",
              _0: stringValue(rng)
            };
  }
}

function compareOp(rng) {
  return Core__Option.getOr(pick(rng, FormDB_Property_Types.allCompareOps), "Eq");
}

function whereClause(rng) {
  var field = fieldName(rng);
  var op = compareOp(rng);
  var value = valueType(rng);
  return field + " " + FormDB_Property_Types.compareOpToString(op) + " " + FormDB_Property_Types.valueToString(value);
}

function selectStatement(rng) {
  var collection = identifier(rng);
  var numFields = intInRange(rng, 1, 4);
  var fields = [];
  for(var _for = 1; _for <= numFields; ++_for){
    fields.push(fieldName(rng));
  }
  var fieldList = fields.join(", ");
  var hasWhere = bool(rng);
  var hasLimit = bool(rng);
  var base = "SELECT " + fieldList + " FROM " + collection;
  var withWhere = hasWhere ? base + " WHERE " + whereClause(rng) : base;
  if (hasLimit) {
    return withWhere + " LIMIT " + intInRange(rng, 1, 100).toString();
  } else {
    return withWhere;
  }
}

function insertStatement(rng) {
  var collection = identifier(rng);
  var numFields = intInRange(rng, 1, 4);
  var pairs = [];
  for(var _for = 1; _for <= numFields; ++_for){
    var field = fieldName(rng);
    var value = valueType(rng);
    pairs.push("\"" + field + "\": " + FormDB_Property_Types.valueToString(value));
  }
  var $$document = "{" + pairs.join(", ") + "}";
  return "INSERT INTO " + collection + " " + $$document;
}

function updateStatement(rng) {
  var collection = identifier(rng);
  var numFields = intInRange(rng, 1, 3);
  var pairs = [];
  for(var _for = 1; _for <= numFields; ++_for){
    var field = fieldName(rng);
    var value = valueType(rng);
    pairs.push("\"" + field + "\": " + FormDB_Property_Types.valueToString(value));
  }
  var setClause = "{" + pairs.join(", ") + "}";
  return "UPDATE " + collection + " SET " + setClause + " WHERE " + whereClause(rng);
}

function deleteStatement(rng) {
  var collection = identifier(rng);
  return "DELETE FROM " + collection + " WHERE " + whereClause(rng);
}

function createStatement(rng) {
  var collection = identifier(rng);
  var isEdge = bool(rng);
  var collType = isEdge ? "EDGE COLLECTION" : "COLLECTION";
  return "CREATE " + collType + " " + collection;
}

function dropStatement(rng) {
  var collection = identifier(rng);
  return "DROP COLLECTION " + collection;
}

function explainStatement(rng) {
  var inner = selectStatement(rng);
  var verbose = bool(rng);
  var analyze = bool(rng);
  var prefix = analyze ? (
      verbose ? "EXPLAIN ANALYZE VERBOSE" : "EXPLAIN ANALYZE"
    ) : (
      verbose ? "EXPLAIN VERBOSE" : "EXPLAIN"
    );
  return prefix + " " + inner;
}

function introspectStatement(rng) {
  var targets = [
    "SCHEMA",
    "CONSTRAINTS",
    "COLLECTIONS",
    "JOURNAL"
  ];
  var target = Core__Option.getOr(pick(rng, targets), "SCHEMA");
  switch (target) {
    case "CONSTRAINTS" :
    case "SCHEMA" :
        break;
    default:
      return "INTROSPECT " + target;
  }
  var collection = identifier(rng);
  return "INTROSPECT " + target + " " + collection;
}

function fdqlStatement(rng) {
  var stmtType = Core__Option.getOr(pick(rng, FormDB_Property_Types.allStatementTypes), "Select");
  switch (stmtType) {
    case "Select" :
        return selectStatement(rng);
    case "Insert" :
        return insertStatement(rng);
    case "Update" :
        return updateStatement(rng);
    case "Delete" :
        return deleteStatement(rng);
    case "Create" :
        return createStatement(rng);
    case "Drop" :
        return dropStatement(rng);
    case "Explain" :
        return explainStatement(rng);
    case "Introspect" :
        return introspectStatement(rng);
    
  }
}

function fdqlStatements(rng, count) {
  var result = [];
  for(var _for = 1; _for <= count; ++_for){
    result.push(fdqlStatement(rng));
  }
  return result;
}

export {
  makeRng ,
  nextInt ,
  intInRange ,
  float01 ,
  bool ,
  pick ,
  identifier ,
  fieldName ,
  stringValue ,
  valueType ,
  compareOp ,
  whereClause ,
  selectStatement ,
  insertStatement ,
  updateStatement ,
  deleteStatement ,
  createStatement ,
  dropStatement ,
  explainStatement ,
  introspectStatement ,
  fdqlStatement ,
  fdqlStatements ,
}
/* No side effect */
